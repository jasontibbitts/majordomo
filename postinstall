# Post-installation script for Majordomo

# Basic functions:
#   1. Create the list hierarchy if necessary.
#   2. Make sure the permissions and ownerships are proper.
#   3. Convert 1.x lists.
#   (etc.  Perhaps spit out aliases?)

use DirHandle;
use File::Copy "cp";
sub dot ();

# We call mj_shell (which we make sure has the right permissions) to do the
# dirty work; it would be possible to include the routines directly, but
# this makes sure that everything was installed correctly.  It's better to
# bomb here than to let a bad installation slip by.

$config = eval { require ".mj_config" };
die "Can't do postinstall unless Makefile.PL has been run!"
  unless $config;

@dirs = (); %files = (); # Silence warning.
die "Can't get file index, $!"
  unless eval { require "files/INDEX.pl" };

# Pull some variables from the environment 
$ask   = $ENV{ASK};
$skip  = $ENV{SKIP};
$verb  = $ENV{VERBOSE};
$quiet = $ENV{QUIET};
$| = 1;

# List of script files to be installed.
@sidscripts = (qw(mj_resend mj_shell mj_email mj_confirm));
@scripts = (qw(mj_trigger));

$msg0 = <<EOM;

Your global password must be known for some of the installation process,
 but it is insecure to store it anywhere outside of Majordomo.  Thus you
 must enter it now.  If you have not yet set a password, choose one and
 enter it below.

What is the global password for domain \$DOM?
EOM

$msg0s = <<EOM;

What is the global password for domain \$DOM?
EOM

$msg1 = <<EOM;

Majordomo stores its lists in a hiearachy of directories.  These can be
 created for you now.  The various list files will be created as needed.
 If you do not answer yes, and the necessary directories do not already
 exist, the rest of the installation will fail.

Create directories?
EOM

$msg2 = <<EOM;

The installation can do some basic global configuration using the questions
 answered before installation began.

If you do not do this, the rest of the installation may not proceed
 correctly, since the global password needs to be set in order for this
 program to make configuration changes.

Do basic global configuration now?
EOM

$msg3 = <<EOM;

Majordomo stores response files (the confirmation message, the various help
 texts, etc.) separately instead of placing them into the program code.
 These files must be installed into the Majordomo system.  Note that these
 go into a special file area and will not overrwite any response files
 which have been uploaded.

Install response files?
EOM

set_script_perms(\@sidscripts, \@scripts);

if ($config->{cgi_bin}) {
  copy_file('mj_confirm', "$config->{install_dir}/bin",
	    $config->{cgi_bin}, $config->{cgi_link});
}

# Create list directories and such
if (!$skip && (!$ask || get_bool($msg1))) {
  create_dirs($config->{'lists_dir'},
	      scalar getpwnam($config->{'uid'}),
	      scalar getgrnam($config->{'gid'}),
	      $config->{'umask'},
	      $config->{'domains'},
	      $config->{'tmpdir'},
	     );
}

# Configure a few global parameters
if (!$skip && (!$ask || get_bool($msg2))) {
  for my $i (@{$config->{'domains'}}) {
    do_config($i);
  }
}

# Convert lists if desired

# Install response files
if (!$skip && (!$ask || get_bool($msg3))) {
  for my $i (@{$config->{'domains'}}) {
    install_response_files($i, $config->{'domain'}{$i}{'password'},
			   \%files, \@dirs);
  }
}

# Give some basic MTA configuration
if (!$skip && -t STDIN) {
  print "\nSome basic configuration information:\n";
  my $nhead = 0;
  for my $i (@{$config->{'domains'}}) {
    suggest_mta($i, $nhead);
    $nhead = 1;
  }
}

if (!$skip && !$quiet && -t STDIN) {
  print <<"EOM";

You may also wish to add the following entries to the $config->{'uid'}
account\'s crontab:
EOM
}
open OUT, ">$config->{install_dir}/majordomo.crontab" or
  die "Can't open sample crontab file, $!";
print OUT <<EOM;
# This is a set of sample crontab entries.
EOM
  
my $ct;
for my $i (@{$config->{'domains'}}) {
  $ct = suggest_crontab($i);
  print $ct if -t STDIN && (!$skip && !$quiet);
  print OUT $ct;
}

close OUT;
chown (scalar getpwnam($config->{'uid'}),
       scalar getgrnam($config->{'gid'}),
       "$config->{install_dir}/majordomo.crontab") or
  die "Can't chown $config->{install_dir}/majordomo.crontab, $!";
chmod (0755, "$config->{install_dir}/majordomo.crontab") or
  die "Can't chmod $config->{install_dir}/majordomo.crontab, $!";

exit;

# Copies or links a file from one directory to another, preserving
# ownership and permissions.
sub copy_file {
  my $script = shift;
  my $source = shift;
  my $dest   = shift;
  my $link   = shift;

  if ($link) {
    link "$source/$script", "$dest/$script" ||
      die "Can't make link in $dest, $!.";
  }
  else {
    cp("$source/$script", "$dest/$script") ||
      die "Can't copy $source/$script to $dest/$script, $!.";
    # Set the owner and mode on the copied file
    chown((stat("$source/$script"))[4,5], "$dest/$script");
    chmod((stat(_))[2], "$dest/$script");
  }
}

sub set_script_perms {
  my $sidscripts = shift;
  my $scripts    = shift;
  print "Setting permissions:" unless $quiet;
  $id = $config->{'install_dir'};
  if ($config->{wrappers}) {
    for my $i (@$sidscripts) {
      push @$scripts, ".$i";
    }
  }
  map {$_ = "$id/bin/$_" unless /\//} @$sidscripts, @$scripts;

  $uid = getpwnam($config->{'uid'});
  $gid = getgrnam($config->{'gid'});

  # Properly set ownerships on everything.
  chown($uid, $gid, @$sidscripts, @$scripts) || die "Couldn't change ownership: $!";
  dot;
  chown($uid, $gid, $id);dot;
  rchown($uid, $gid, 0644, 0755, "$id/bin", "$id/man", "$id/lib");dot;

  # Make executables setuid; the scripts must be readable while the the
  # wrappers need only be executable.
  if ($config->{'wrappers'}) {
    chmod(06111, @$sidscripts) || die "Couldn't change mode: $!";
  }
  else {
    chmod(06555, @$sidscripts) || die "Couldn't change mode: $!";
  }
  dot;
  chmod(0555, @$scripts);dot;
  print "ok\n" unless $quiet;
}

sub create_dirs {
  my $l    = shift;
  my $uid  = shift;
  my $gid  = shift;
  my $um   = shift;
  my $doms = shift;
  my $tmp  = shift;
  my($i);

  print "Making directories:" unless $quiet;
  print "$l, $tmp, $uid, $gid\n" if $verb;

  safe_mkdir($l,           0777 & ~oct($um), $uid, $gid);dot;
  safe_mkdir($tmp,         0777 & ~oct($um), $uid, $gid);dot;
  safe_mkdir("$tmp/locks", 0777 & ~oct($um), $uid, $gid);dot;
  
  for $i (@$doms) {
    printf "Making directories for %s, mode %lo.\n", $i, (0777 & ~oct($um))
      if $verb;
    safe_mkdir("$l/$i", 0777 & ~oct($um), $uid, $gid);dot;
    safe_mkdir("$l/$i/GLOBAL", 0777 & ~oct($um), $uid, $gid);dot;
    safe_mkdir("$l/$i/GLOBAL/files", 0777 & ~oct($um), $uid, $gid);dot;
    safe_mkdir("$l/$i/GLOBAL/sessions", 0777 & ~oct($um), $uid, $gid);dot;
  }
  print "ok.\n" unless $quiet;
}

# Set basic config vars
sub do_config {
  my $dom = shift;
  # Do everything from the global $config
  my(@args, $arg, $i, $ignore, $msg, $pw);

  # Prompt for the password if necessary
  $pw = $config->{'domain'}{$dom}{'master_password'};
  unless ($pw) {
    ($msg = $msg0) =~ s/\$DOM/$dom/;
    $pw = get_str($msg);
    $config->{'domain'}{$dom}{'master_password'} = $pw;
    $msg0 = $msg0s; # Switch to using the short prompt.
  }
  print "Configuring $dom:" unless $quiet;

  # Build the command line
  @args = ("$config->{'install_dir'}/bin/mj_shell", "-d", "$dom", "-F",
	   "$config->{wtmpdir}/inst.$$");

  # Build the command file
  open FILE, ">$config->{wtmpdir}/inst.$$";
  print FILE "approve GLOBAL.pass configset GLOBAL master_password = $pw\n";
  print FILE "default password $pw\n";
  for $i (qw(tmpdir site_name whoami install_dir lists_dir mta)) {
    $arg = $config->{'domain'}{$dom}{$i} || $config->{$i};
    print FILE "configset GLOBAL $i = $arg\n";
  }
  print FILE "configset GLOBAL whereami = $dom\n";
  close FILE;
  # Make sure the file can be read by the Majordomo user.  XXX This is a
  # slight security hole.  We're root, so we should play with chowning the
  # file.
  chmod(0644, "$config->{wtmpdir}/inst.$$");dot;

  print "\nDo not be alarmed if the first command fails.\n\n@args\n" if $verb;

#  system(@args) == 0 or die "Error executing $args[0], $?";
  $cmdline = join(' ', @args);
  open SHELL, "$cmdline|" or die "Error executing $args[0], $?";
  while (<SHELL>) {
    print if $verb;
    dot if />>>> / && !$verb;
  }
  close SHELL;
  unlink "$config->{wtmpdir}/inst.$$";
  print "ok.\n" unless $quiet;
}

sub install_response_files {
  my $dom   = shift;
  my $pass  = shift;
  my $files = shift;
  my $dirs  = shift;
  my(@args, @dirs, $dir, $file, $i, $lang, $subj);

  # Grab the password if necessary
  $pw = $config->{'domain'}{$dom}{'master_password'};
  unless ($pw) {
    ($msg = $msg0) =~ s/\$DOM/$dom/;
    $pw = get_str($msg);
    $config->{'domain'}{$dom}{'master_password'} = $pw;
    $msg0 = $msg0s; # Switch to using the short prompt.
  }
  print "Installing response files for $dom:" unless $quiet;

  # Copy dirs so we don't destroy the original array
  @dirs = @$dirs;

  @args = ("$config->{'install_dir'}/bin/mj_shell", "-d", "$dom", "-F",
	   "$config->{wtmpdir}/inst.$$");

  # Build the command file
  open FILE, ">$config->{wtmpdir}/inst.$$";
  print FILE "default password $pw\n";
  # Make the directories
  while (($dir, $subj) = splice(@dirs, 0, 2)) {
    print FILE "put-dir GLOBAL /$dir $subj\n";
  }
  # Put the files
  $i = 1;
  while (($file, $subj) = each %{$files}) {

    # Extract the language to use
    ($lang) = $file =~ m!^([^/]*)!;
    if ($file =~ m!/informal/!) {
      $lang .= "(informal)";
    }

    # If we have a ref instead of a string for the subject
    if (ref($subj)) {
      print FILE "put-data GLOBAL /stock/$file text/plain $$subj[1] $$subj[2] $lang $$subj[0] <\@$i\n";
      # Copy each file into the temp area, so Majordomo can read it.
      if ($$subj[3]) {
	cp("files/$$subj[3]", "$config->{wtmpdir}/inst.$$.$i");
      }
      else {
	cp("files/$file", "$config->{wtmpdir}/inst.$$.$i");
      }
    }

    # Else assume we have an European language and use appropriate defaults.
    else {
      print FILE "put-data GLOBAL /stock/$file text/plain ISO-8859-1 8bit $lang $subj <\@$i\n";
      cp("files/$file", "$config->{wtmpdir}/inst.$$.$i");
    }
    chmod(0644, "$config->{wtmpdir}/inst.$$.$i");
    push @args, ("-f", "$config->{wtmpdir}/inst.$$.$i");
    $i++;
  }
  close FILE;
  chmod(0644, "$config->{wtmpdir}/inst.$$");

  # Now run the generated command line, piping the output back to us so we
  # can hide it from the user.
  $cmdline = join(' ', @args);
  print "$cmdline\n" if $verb;
  open SHELL, "$cmdline|" or die "Error executing $args[0], $?";
  while (<SHELL>) {
    print if $verb;
    dot if />>>> / && !$verb;
  }
  close SHELL;

  # Now clean up all of those temporary files we made.
  unlink "$config->{wtmpdir}/inst.$$";
  while ($i > 0) {
    unlink "$config->{wtmpdir}/inst.$$.$i";
    $i--;
  }
  print "ok.\n" unless $quiet;
}

sub suggest_mta {
  my $dom   = shift;
  my $nhead = shift;
  my $pw;

  $pw = $config->{'domain'}{$dom}{'master_password'};
  unless ($pw) {
    ($msg = $msg0) =~ s/\$DOM/$dom/;
    $pw = get_str($msg);
    $config->{'domain'}{$dom}{'master_password'} = $pw;
    $msg0 = $msg0s; # Switch to using the short prompt.
  }

  my @args = ("$config->{'install_dir'}/bin/mj_shell", "-d", "$dom", "-p",
	      "$pw", "createlist-quiet" . ($nhead ? ",noheader" :
	      ''), "GLOBAL $config->{domain}{$dom}{owner}");

#  print "(@args)\n";
  system(@args) == 0 or die "Error executing $args[0], $?";
}

sub suggest_crontab {
  my $dom = shift;
  return <<"EOM";

# Daily and hourly triggers for $dom
0 0 * * * $config->{'install_dir'}/bin/mj_trigger -d $dom -t daily
0 * * * * $config->{'install_dir'}/bin/mj_trigger -d $dom -t hourly
EOM
}

  

sub get_str {
  return prompt(shift, shift);
}

sub get_bool {
  my ($msg, $def) = @_;
  chomp $msg;
  my $val = prompt($msg, $def ? "yes" : "no");
  $val =~ /^y/i ? 1:0;
}

sub prompt ($;$) {
  my($mess,$def)=@_;
  my $ISA_TTY = -t STDIN && -t STDOUT ;
  Carp::confess("prompt function called without an argument") unless defined $mess;
  my $dispdef = defined $def ? "[$def] " : " ";
  $def = defined $def ? $def : "";
  my $ans;
  if ($ISA_TTY) {
    local $|=1;
    print "$mess $dispdef->";
    chomp($ans = <STDIN>);
  }
  return $ans || $def;
}
	    
sub safe_mkdir {
  my $dir  = shift;
  my $mode = shift;
  my $uid  = shift;
  my $gid  = shift;
  unless (-d $dir) {
    mkdir $dir, $mode or die "Can't make $dir, $!";
    chown ($uid, $gid, $dir) or die "Can't chown $dir, $!";
    chmod ($mode, $dir) or die "Can't chmod $dir, $!";
  }
}

sub rchown {
  my $uid = shift;
  my $gid = shift;
  my $mod = shift;
  my $dmod = shift;
  my ($dh, $dir);

  for $dir (@_) {
    dot;
    $dir =~ s!/$!!;
    
    $dh = DirHandle->new($dir);
    chown($uid, $gid, $dir) || die("Couldn't chown $dir, $!");
    chmod($dmod, $dir);
    for my $i ($dh->read) {
      next if $i eq '.' || $i eq '..';
      chown($uid, $gid, "$dir/$i") || die("Couldn't chown $dir/$i, $!");
      chmod($mod, "$dir/$i") || die("Couldn't chmod $dir/$i, $!");
      if (-d "$dir/$i") {
	rchown($uid, $gid, $mod, $dmod, "$dir/$i");
      }
    }
  }
}

sub dot () {
  print "." unless $quiet;
}
1;
#
### Local Variables: ***
### mode:cperl ***
### cperl-indent-level:2 ***
### End: ***
