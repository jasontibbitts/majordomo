# Post-installation script for Majordomo

# Basic functions:
#   1. Create the list hierarchy if necessary.
#   2. Make sure the permissions and ownerships are proper.
#   3. Convert 1.x lists.
#   (etc.  Perhaps spit out aliases?)

use DirHandle;
use File::Copy "cp";
use Data::Dumper;
sub dot ();

# We call mj_shell (which we make sure has the right permissions) to do the
# dirty work; it would be possible to include the routines directly, but
# this makes sure that everything was installed correctly.  It's better to
# bomb here than to let a bad installation slip by.

$config = eval { require ".mj_config" };
die "Can't do postinstall unless Makefile.PL has been run!"
  unless $config;

#@dirs = (); %files = (); # Silence warning.
# die "Can't get file index, $!"
#   unless eval { require "files/INDEX.pl" };

# Pull some variables from the environment 
$ask   = $ENV{ASK};
$skip  = $ENV{SKIP};
$verb  = $ENV{VERBOSE};
$quiet = $ENV{QUIET};
$| = 1;

# List of script files to be installed.
@sidscripts = (qw(mj_resend mj_shell mj_email mj_confirm));
@scripts = (qw(mj_trigger));

$msg0 = <<EOM;

Your global password must be known for some of the installation process,
 but it is insecure to store it anywhere outside of Majordomo.  Thus you
 must enter it now.  If you have not yet set a password, choose one and
 enter it below.

What is the global password for domain \$DOM?
EOM

$msg0s = <<EOM;

What is the global password for domain \$DOM?
EOM

# $msg1 = <<EOM;

# Majordomo stores its lists in a hiearachy of directories.  These can be
#  created for you now.  The various list files will be created as needed.
#  If you do not answer yes, and the necessary directories do not already
#  exist, the rest of the installation will fail.

# Create directories?
# EOM

$msg2 = <<EOM;

The installation can do some basic global configuration using the questions
 answered before installation began.

If you do not do this, the rest of the installation may not proceed
 correctly, since the global password needs to be set in order for this
 program to make configuration changes.

Do basic global configuration now?
EOM

# $msg3 = <<EOM;

# Majordomo stores response files (the confirmation message, the various help
#  texts, etc.) separately instead of placing them into the program code.
#  These files must be installed into the Majordomo system.  Note that these
#  go into a special file area and will not overrwite any response files
#  which have been uploaded.

# Install response files?
# EOM

$msg4 = <<EOM;

Your master site password must be known for some of the installation
 process, but it is insecure to store it anywhere outside of Majordomo.
 Thus you must enter it now.  If you have not yet set a password, choose
 one and enter it below.

What is the site password?
EOM

set_script_perms(\@sidscripts, \@scripts);

if ($config->{cgi_bin}) {
  copy_file('mj_confirm', "$config->{install_dir}/bin",
	    $config->{cgi_bin}, $config->{cgi_link});
}

# Create list directories and such
create_dirs($config->{'lists_dir'},
	    scalar getpwnam($config->{'uid'}),
	    scalar getgrnam($config->{'gid'}),
	    $config->{'umask'},
	    $config->{'domains'},
	    $config->{'tmpdir'},
	   );

# Install response files
install_response_files();

# Make the site config
do_site_config();

# Configure a few global parameters
if (!$skip && (!$ask || get_bool($msg2))) {
  for my $i (@{$config->{'domains'}}) {
    do_config($i);
  }
}

# Convert lists if desired

# Give some basic MTA configuration
if (!$skip && -t STDIN) {
  print "\nSome basic configuration information:\n";
  my $nhead = 0;
  for my $i (@{$config->{'domains'}}) {
    suggest_mta($i, $nhead);
    $nhead = 1;
  }
}

if (!$skip && !$quiet && -t STDIN) {
  print <<"EOM";

You may also wish to add the following entries to the $config->{'uid'}
account\'s crontab:
EOM
}
open OUT, ">$config->{install_dir}/majordomo.crontab" or
  die "Can't open sample crontab file, $!";
print OUT <<EOM;
# This is a set of sample crontab entries.
EOM
  
my $ct;
for my $i (@{$config->{'domains'}}) {
  $ct = suggest_crontab($i);
  print $ct if -t STDIN && (!$skip && !$quiet);
  print OUT $ct;
}

close OUT;
chown (scalar getpwnam($config->{'uid'}),
       scalar getgrnam($config->{'gid'}),
       "$config->{install_dir}/majordomo.crontab") or
  die "Can't chown $config->{install_dir}/majordomo.crontab, $!";
chmod (0755, "$config->{install_dir}/majordomo.crontab") or
  die "Can't chmod $config->{install_dir}/majordomo.crontab, $!";

exit;

# Copies or links a file from one directory to another, preserving
# ownership and permissions.
sub copy_file {
  my $script = shift;
  my $source = shift;
  my $dest   = shift;
  my $link   = shift;

  if ($link) {
    link "$source/$script", "$dest/$script" ||
      die "Can't make link in $dest, $!.";
  }
  else {
    cp("$source/$script", "$dest/$script") ||
      die "Can't copy $source/$script to $dest/$script, $!.";
    # Set the owner and mode on the copied file
    chown((stat("$source/$script"))[4,5], "$dest/$script");
    chmod((stat(_))[2], "$dest/$script");
  }
}

sub set_script_perms {
  my $sidscripts = shift;
  my $scripts    = shift;
  print "Setting permissions:" unless $quiet;
  $id = $config->{'install_dir'};
  if ($config->{wrappers}) {
    for my $i (@$sidscripts) {
      push @$scripts, ".$i";
    }
  }
  map {$_ = "$id/bin/$_" unless /\//} @$sidscripts, @$scripts;

  $uid = getpwnam($config->{'uid'});
  $gid = getgrnam($config->{'gid'});

  # Properly set ownerships on everything.
  chown($uid, $gid, @$sidscripts, @$scripts) || die "Couldn't change ownership: $!";
  dot;
  chown($uid, $gid, $id);dot;
  rchown($uid, $gid, 0644, 0755, "$id/bin", "$id/man", "$id/lib");dot;

  # Make executables setuid; the scripts must be readable while the the
  # wrappers need only be executable.
  if ($config->{'wrappers'}) {
    chmod(06111, @$sidscripts) || die "Couldn't change mode: $!";
  }
  else {
    chmod(06555, @$sidscripts) || die "Couldn't change mode: $!";
  }
  dot;
  chmod(0555, @$scripts);dot;
  print "ok\n" unless $quiet;
}

sub create_dirs {
  my $l    = shift;
  my $uid  = shift;
  my $gid  = shift;
  my $um   = shift;
  my $doms = shift;
  my $tmp  = shift;
  my($i);

  print "Making directories:" unless $quiet;
  print "$l, $tmp, $uid, $gid\n" if $verb;

  safe_mkdir($l,           0777 & ~oct($um), $uid, $gid);dot;
  safe_mkdir($tmp,         0777 & ~oct($um), $uid, $gid);dot;
  safe_mkdir("$tmp/locks", 0777 & ~oct($um), $uid, $gid);dot;

  safe_mkdir("$l/SITE",       0777 & ~oct($um), $uid, $gid);dot;
  safe_mkdir("$l/SITE/files", 0777 & ~oct($um), $uid, $gid);dot;
  
  for $i (@$doms) {
    printf "ok.\nMaking directories for %s, mode %lo.\n", $i, (0777 & ~oct($um))
      if $verb;
    safe_mkdir("$l/$i",                 0777 & ~oct($um), $uid, $gid);dot;
    safe_mkdir("$l/$i/GLOBAL",          0777 & ~oct($um), $uid, $gid);dot;
    safe_mkdir("$l/$i/GLOBAL/sessions", 0777 & ~oct($um), $uid, $gid);dot;
  }
  print "ok.\n" unless $quiet;
}

# Set basic config vars
sub do_config {
  my $dom = shift;
  my(@args, $arg, $errcount, $i, $ignore, $msg, $pw);

  # Prompt for the password if necessary
  $pw = $config->{'domain'}{$dom}{'master_password'};
  unless ($pw) {
    ($msg = $msg0) =~ s/\$DOM/$dom/;
    $pw = get_str($msg);
    $config->{'domain'}{$dom}{'master_password'} = $pw;
    $msg0 = $msg0s; # Switch to using the short prompt.
  }
  print "Configuring $dom:" unless $quiet;

  # Build the command line
  @args = ("$config->{'install_dir'}/bin/mj_shell", "-d", "$dom", "-F",
	   "$config->{wtmpdir}/inst.$$");

  # Build the command file
  open FILE, ">$config->{wtmpdir}/inst.$$";
  print FILE "approve GLOBAL.pass configset GLOBAL master_password = $pw\n";
  print FILE "default password $pw\n";
  for $i (qw(tmpdir site_name whoami)) {
    $arg = $config->{'domain'}{$dom}{$i} || $config->{$i};
    print FILE "configset GLOBAL $i = $arg\n";
  }
  print FILE "configset GLOBAL whereami = $dom\n";
  close FILE;
  # Make sure the file can be read by the Majordomo user.  XXX This is a
  # slight security hole.  We're root, so we should play with chowning the
  # file.
  chmod(0644, "$config->{wtmpdir}/inst.$$");dot;

  print "\nDo not be alarmed if the first command fails.\n\n@args\n" if $verb;

  $cmdline = join(' ', @args);
  open SHELL, "$cmdline|" or die "Error executing $args[0], $?";
  while (<SHELL>) {
    print if $verb;
    dot if /^>>>> / && !$verb;
    if (/^\*\*\*\* / && !/Password does not authorize .* to alter master_password./) {
      print unless $verb;
      $errcount++;
    }
  }
  close SHELL;
  unlink "$config->{wtmpdir}/inst.$$";

  if ($errcount) {
    print "\nWarning: there were unexpected errors!\nInstallation may be incorrect!\n";
  }
  else {
    print "ok.\n" unless $quiet;
  }
}

# Dump out the initial site config
sub do_site_config {
  my $data;

  # Prompt for the site password if necessary
  $pw = $config->{'site_password'};
  unless ($pw) {
    $pw = get_str($msg4);
    $config->{'site_password'} = $pw;
  }

  print "Cnfiguring site-wide parameters:";

  # Build up the Data hash.
  $data = {
	   'site_password' => $pw,
	   'install_dir'   => $config->{'install_dir'},
	   'mta'           => $config->{'mta'},
	   'cgi_bin'       => $config->{'cgi_bin'},
	  };

  # Open the site config file
  open SITE, ">$config->{'lists_dir'}/SITE/config.pl"
    or die "Couldn't open site config file $config->{'lists_dir'}/SITE/config.pl: $!";
  dot;

  # Print out the data hash
  print SITE Dumper($data)
    or die "Couldn't populate site config file $config->{'lists_dir'}/SITE/config.pl: $!";
  dot;

  # Close the file
  close SITE;
  dot;

  # Change ownership and permissions
  chown (scalar getpwnam($config->{'uid'}),
	 scalar getgrnam($config->{'gid'}),
	 "$config->{'lists_dir'}/SITE/config.pl")
    or die "Can't chown $config->{'lists_dir'}/SITE/config.pl: $!";
  dot;

  chmod ((0777 & ~oct($config->{'umask'}), "$config->{'lists_dir'}/SITE/config.pl"))
    or die "Can't chmod $config->{install_dir}/majordomo.crontab, $!";

  print ".ok.\n" unless $quiet;
}

# Copy all of the stock response files into their site-wide directory
sub install_response_files {
  my ($gid, $uid);

  print "Installing stock response files:" unless $quiet;

  rcopy("files", "$config->{'lists_dir'}/SITE/files", 1);
  
  $uid = getpwnam($config->{'uid'});
  $gid = getgrnam($config->{'gid'});
  $um  = oct($config->{'umask'});
  rchown($uid, $gid, 0666 & ~$um, 0777 & ~$um,
	 "$config->{'lists_dir'}/SITE/files");
  print "ok.\n" unless $quiet;
}

# Recursively copy one directory to another, not paying attention to
# ownership or permisions.
sub rcopy {
  my $src = shift;
  my $dst = shift;
  my $dot = shift;
  my ($i);

  $src =~ s!/$!!; # Strip trailing slash
  $dst =~ s!/$!!; # Strip trailing slash

  $dh = DirHandle->new($src);
  for $i ($dh->read) {
    next if $i eq '.' || $i eq '..' || $i eq 'CVS';
    if (-d "$src/$i") {
      unless (-d "$dst/$i") {
	mkdir("$dst/$i", 0700)
	  or die "Can't make directory $dst/$i: $!";
	dot if $dot;
      }
      rcopy("$src/$i", "$dst/$i", $dot);
    }
    else {
      cp("$src/$i", "$dst/$i")
	or die "Can't copy to $dst/$i: $!";
      dot if $dot;
    }
  }
}

sub suggest_mta {
  my $dom   = shift;
  my $nhead = shift;
  my $pw;

  $pw = $config->{'domain'}{$dom}{'master_password'};
  unless ($pw) {
    ($msg = $msg0) =~ s/\$DOM/$dom/;
    $pw = get_str($msg);
    $config->{'domain'}{$dom}{'master_password'} = $pw;
    $msg0 = $msg0s; # Switch to using the short prompt.
  }

  my @args = ("$config->{'install_dir'}/bin/mj_shell", "-d", "$dom", "-p",
	      "$pw", "createlist-quiet" . ($nhead ? ",noheader" :
	      ''), "GLOBAL $config->{domain}{$dom}{owner}");

#  print "(@args)\n";
  system(@args) == 0 or die "Error executing $args[0], $?";
}

sub suggest_crontab {
  my $dom = shift;
  return <<"EOM";

# Daily and hourly triggers for $dom
0 0 * * * $config->{'install_dir'}/bin/mj_trigger -d $dom -t daily
0 * * * * $config->{'install_dir'}/bin/mj_trigger -d $dom -t hourly
EOM
}

  

sub get_str {
  return prompt(shift, shift);
}

sub get_bool {
  my ($msg, $def) = @_;
  chomp $msg;
  my $val = prompt($msg, $def ? "yes" : "no");
  $val =~ /^y/i ? 1:0;
}

sub prompt ($;$) {
  my($mess,$def)=@_;
  my $ISA_TTY = -t STDIN && -t STDOUT ;
  Carp::confess("prompt function called without an argument") unless defined $mess;
  my $dispdef = defined $def ? "[$def] " : " ";
  $def = defined $def ? $def : "";
  my $ans;
  if ($ISA_TTY) {
    local $|=1;
    print "$mess $dispdef->";
    chomp($ans = <STDIN>);
  }
  return $ans || $def;
}
	    
sub safe_mkdir {
  my $dir  = shift;
  my $mode = shift;
  my $uid  = shift;
  my $gid  = shift;
  unless (-d $dir) {
    mkdir $dir, $mode or die "Can't make $dir, $!";
    chown ($uid, $gid, $dir) or die "Can't chown $dir, $!";
    chmod ($mode, $dir) or die "Can't chmod $dir, $!";
  }
}

sub rchown {
  my $uid = shift;
  my $gid = shift;
  my $mod = shift;
  my $dmod = shift;
  my ($dh, $dir);

  for $dir (@_) {
    dot;
    $dir =~ s!/$!!;
    
    $dh = DirHandle->new($dir);
    chown($uid, $gid, $dir) || die("Couldn't chown $dir, $!");
    chmod($dmod, $dir);
    for my $i ($dh->read) {
      next if $i eq '.' || $i eq '..';
      chown($uid, $gid, "$dir/$i") || die("Couldn't chown $dir/$i, $!");
      chmod($mod, "$dir/$i") || die("Couldn't chmod $dir/$i, $!");
      if (-d "$dir/$i") {
	rchown($uid, $gid, $mod, $dmod, "$dir/$i");
      }
    }
  }
}

sub dot () {
  print "." unless $quiet;
}
1;
#
### Local Variables: ***
### cperl-indent-level:2 ***
### End: ***
