# Post-installation script for Majordomo

# Basic functions:
#   1. Create the list hierarchy if necessary.
#   2. Make sure the permissions and ownerships are proper.
#   3. Convert 1.x lists.
#   (etc.  Perhaps spit out aliases?)

use DirHandle;
use File::Copy "cp";
use Data::Dumper;
require "setup/query_util.pl";
sub dot ();

# We call mj_shell (which we make sure has the right permissions) to do the
# dirty work; it would be possible to include the routines directly, but
# this makes sure that everything was installed correctly.  It's better to
# bomb here than to let a bad installation slip by.

$config = eval { require ".mj_config" };
die "Can't do postinstall unless Makefile.PL has been run!"
  unless $config;

#@dirs = (); %files = (); # Silence warning.
# die "Can't get file index, $!"
#   unless eval { require "files/INDEX.pl" };

# Pull some variables from the environment 
$ask   = $ENV{ASK};
$skip  = $ENV{SKIP};
$verb  = $ENV{VERBOSE};
$quiet = $ENV{QUIET};
$| = 1;

# List of script files to be installed.
@sidscripts = (qw(mj_resend mj_shell mj_email mj_confirm));
@scripts = (qw(mj_trigger));

$msg0 = <<EOM;

What is the default global password for domain \$DOM?
EOM

$msg2 = <<EOM;

The installation can do some basic global configuration using the questions
 answered before installation began.

If you do not do this, the rest of the installation may not proceed
 correctly, since the global password needs to be set in order for this
 program to make configuration changes.

Do basic global configuration now?
EOM

$msg4 = <<EOM;

Your master site password must be known for some of the installation
 process, but it is insecure to store it anywhere outside of Majordomo.
 Thus you must enter it now.  If you have not yet set a password, choose
 one and enter it below.

What is the site password?
EOM

set_script_perms(\@sidscripts, \@scripts);

if ($config->{cgi_bin}) {
  copy_file('mj_confirm', "$config->{install_dir}/bin",
	    $config->{cgi_bin}, $config->{cgi_link});
}

# Create list directories and such
create_dirs($config->{'lists_dir'},
	    scalar getpwnam($config->{'uid'}),
	    scalar getgrnam($config->{'gid'}),
	    $config->{'umask'},
	    $config->{'domains'},
	    $config->{'tmpdir'},
	   );

# Install response files
install_response_files();

# Make the site config
do_site_config();

# Configure a few global parameters
if (!$skip && (!$ask || get_bool($msg2))) {
  for my $i (@{$config->{'domains'}}) {
    do_default_config($i);
    do_config($i);
  }
}

# Convert lists if desired

# Give some basic MTA configuration
if (!$skip && -t STDIN) {
#  print "\nSome basic configuration information:\n";
  my $nhead = 0;
  for my $i (@{$config->{'domains'}}) {
    suggest_mta($i, $nhead);
    $nhead = 1;
  }
}

if ($config->{sendmail_make_symlinks}) {
  print "Making symlinks in $config->{sendmail_symlink_location}";
  for my $i (@{$config->{'domains'}}) {
    make_alias_symlinks($i, $config->{sendmail_symlink_location});
    dot;
  }
  print ".ok\n";
}

if (!$skip && !$quiet && -t STDIN) {
  print <<"EOM";

Please add the following entries to the $config->{'uid'}
account\'s crontab (not to the crontab of root or any other user).
EOM
}
open OUT, ">$config->{install_dir}/majordomo.crontab" or
  die "Can't open sample crontab file, $!";
print OUT <<EOM;
# This is a set of sample crontab entries.
EOM
  
my $ct;
for my $i (@{$config->{'domains'}}) {
  $ct = suggest_crontab($i);
  print $ct if -t STDIN && (!$skip && !$quiet);
  print OUT $ct;
}

close OUT;
chown (scalar getpwnam($config->{'uid'}),
       scalar getgrnam($config->{'gid'}),
       "$config->{install_dir}/majordomo.crontab") or
  die "Can't chown $config->{install_dir}/majordomo.crontab, $!";
chmod (0755, "$config->{install_dir}/majordomo.crontab") or
  die "Can't chmod $config->{install_dir}/majordomo.crontab, $!";

exit;

# Copies or links a file from one directory to another, preserving
# ownership and permissions.
sub copy_file {
  my $script = shift;
  my $source = shift;
  my $dest   = shift;
  my $link   = shift;

  if ($link) {
    link "$source/$script", "$dest/$script" ||
      die "Can't make link in $dest, $!.";
  }
  else {
    cp("$source/$script", "$dest/$script") ||
      die "Can't copy $source/$script to $dest/$script, $!.";
    # Set the owner and mode on the copied file
    chown((stat("$source/$script"))[4,5], "$dest/$script");
    chmod((stat(_))[2], "$dest/$script");
  }
}

sub set_script_perms {
  my $sidscripts = shift;
  my $scripts    = shift;
  print "Setting permissions:" unless $quiet;
  $id = $config->{'install_dir'};
  if ($config->{wrappers}) {
    for my $i (@$sidscripts) {
      push @$scripts, ".$i";
    }
  }
  map {$_ = "$id/bin/$_" unless /\//} @$sidscripts, @$scripts;

  $uid = getpwnam($config->{'uid'});
  $gid = getgrnam($config->{'gid'});

  # Properly set ownerships on everything.
  chown($uid, $gid, @$sidscripts, @$scripts) || die "Couldn't change ownership: $!";
  dot;
  chown($uid, $gid, $id);dot;

  # Change permissions on the top-level installation directory, but make
  # sure that anyone can look in it to run programs.
  chmod((0777 & ~oct($config->{'umask'})) | 0555, $id);dot;
  rchown($uid, $gid, 0644, 0755, "$id/bin", "$id/man", "$id/lib");dot;

  # Make executables setuid; the scripts must be readable while the the
  # wrappers need only be executable.
  if ($config->{'wrappers'}) {
    chmod(06511, @$sidscripts) || die "Couldn't change mode: $!";
  }
  else {
    chmod(06555, @$sidscripts) || die "Couldn't change mode: $!";
  }
  dot;
  chmod(0555, @$scripts);dot;
  print "ok\n" unless $quiet;
}

sub create_dirs {
  my $l    = shift;
  my $uid  = shift;
  my $gid  = shift;
  my $um   = shift;
  my $doms = shift;
  my $tmp  = shift;
  my($i);

  print "Making directories:" unless $quiet;
  print "$l, $tmp, $uid, $gid\n" if $verb;

  safe_mkdir($l,           0777 & ~oct($um), $uid, $gid);dot;
  safe_mkdir($tmp,         0777 & ~oct($um), $uid, $gid);dot;
  safe_mkdir("$tmp/locks", 0777 & ~oct($um), $uid, $gid);dot;

  safe_mkdir("$l/LIB",        0777 & ~oct($um), $uid, $gid);dot;
  safe_mkdir("$l/SITE",       0777 & ~oct($um), $uid, $gid);dot;
  safe_mkdir("$l/SITE/files", 0777 & ~oct($um), $uid, $gid);dot;

  if ($config->{maintain_mtaconfig}) {
    safe_mkdir("$l/ALIASES", 0755 & ~oct($um), $uid, $gid);dot;
  }

  for $i (@$doms) {
    printf "ok.\nMaking directories for %s, mode %lo.\n", $i, (0777 & ~oct($um))
      if $verb;
    safe_mkdir("$l/$i",                    0777 & ~oct($um), $uid, $gid);dot;
    safe_mkdir("$l/$i/GLOBAL",             0777 & ~oct($um), $uid, $gid);dot;
    safe_mkdir("$l/$i/GLOBAL/sessions",    0777 & ~oct($um), $uid, $gid);dot;
    safe_mkdir("$l/$i/GLOBAL/files",       0777 & ~oct($um), $uid, $gid);dot;
  }
  print "ok.\n" unless $quiet;
}

# Set basic config vars
sub do_config {
  my $dom = shift;
  my(@args, $arg, $errcount, $i, $ignore, $msg, $pw);

  # Prompt for the site password if necessary
  $pw = $config->{'site_password'};
  unless ($pw) {
    $pw = get_str($msg4);
    $config->{'site_password'} = $pw;
  }

  print "Configuring $dom:" unless $quiet;

  # Build the command line
  @args = ("$config->{'install_dir'}/bin/mj_shell", "-d", "$dom", "-F",
	   "$config->{wtmpdir}/inst.$$");

  # Build the command file
  open FILE, ">$config->{wtmpdir}/inst.$$";
#  print FILE "approve $config->{site_password} configset GLOBAL master_password = $pw\n";
  print FILE "default password $pw\n";

  # Make the necessary directories in the GLOBAL filespace
  print FILE "put-dir GLOBAL /spool Spooled Files\n";
  print FILE "put-dir GLOBAL /public Public Files\n";
  close FILE;
  # Make sure the file can be read by the Majordomo user.  XXX This is a
  # slight security hole.  We're root, so we should play with chowning the
  # file.
  chmod(0644, "$config->{wtmpdir}/inst.$$");dot;

  $cmdline = join(' ', @args);
  open SHELL, "$cmdline|" or die "Error executing $args[0], $?";
  while (<SHELL>) {
    print if $verb;
    dot if /^>>>> / && !$verb;
    if (/^\*\*\*\* /) {
      print unless $verb;
      $errcount++;
    }
  }
  close SHELL;
  unlink "$config->{wtmpdir}/inst.$$";

  if ($errcount) {
    print "\nWarning: there were unexpected errors!\nInstallation may be incorrect!\n";
  }
  else {
    print "ok.\n" unless $quiet;
  }
}

# This sets appropriate defaults for several config variables
sub do_default_config {
  my $dom = shift;
  my(@args, $arg, $errcount, $i, $ignore, $msg, $owner, $pw);

  # Prompt for the password if necessary
  $pw = $config->{'domain'}{$dom}{'master_password'};
  unless ($pw) {
    ($msg = $msg0) =~ s/\$DOM/$dom/;
    $pw = get_str($msg);
    $config->{'domain'}{$dom}{'master_password'} = $pw;
  }
  print "Setting configuration defaults for $dom:" unless $quiet;

  # Figure out what the owner address should be
  if ($config->{'domain'}{$dom}{whoami} =~ /(.*)\@(.*)/) {
    $owner = "$1-owner\@$2";
  }
  else {
    $owner = "$config->{'domain'}{$dom}{whoami}-owner";
  }

  # Open the master defaults file, in lib/mj_cf_defs.pl
  open MASTER, 'lib/mj_cf_defs.pl';

  # Open the file in $listsdir/LIB/cf_defs_$dom.pl
  open DEFS, ">$config->{lists_dir}/LIB/cf_defs_$dom.pl";

  while (defined($_ = <MASTER>)) {
    # Do substitutions
    s!(^ \'whereami\'.*)DEFAULT(.*)!$1$dom$2!;
    s!(^ \'master_password\'.*)DEFAULT(.*)!$1$config->{'domain'}{$dom}{master_password}$2!;
    s!(^ \'whoami\'.*)DEFAULT(.*)!$1$config->{'domain'}{$dom}{whoami}$2!;
    s!(^ \'whoami_owner\'.*)DEFAULT(.*)!$1$owner$2!;
    s!(^ \'owners\'.*)DEFAULT(.*)!$1$config->{'domain'}{$dom}{owner}$2!;
    
    for $i (qw(tmpdir site_name)) {
      $arg = $config->{'domain'}{$dom}{$i} || $config->{$i};
      s!(^ \'$i\'.*)DEFAULT(.*)!$1$arg$2!;
    }
    print DEFS $_;
  }
  close MASTER;
  close DEFS;

  # Change ownership and permissions
  chown (scalar getpwnam($config->{'uid'}),
	 scalar getgrnam($config->{'gid'}),
	 "$config->{'lists_dir'}/LIB/cf_defs_$dom.pl")
    or die "Can't chown $config->{'lists_dir'}/LIB/cf_defs_$dom.pl: $!";
  dot;

  chmod ((0777 & ~oct($config->{'umask'}), "$config->{'lists_dir'}/LIB/cf_defs_$dom.pl"))
    or die "Can't chmod $config->{'lists_dir'}/LIB/cf_defs_$dom.pl: $!";
  print "ok.\n" unless $quiet;
}


# Dump out the initial site config
sub do_site_config {
  my($data, $mtaopts);

  # Prompt for the site password if necessary
  $pw = $config->{'site_password'};
  unless ($pw) {
    $pw = get_str($msg4);
    $config->{'site_password'} = $pw;
  }

  print "Configuring site-wide parameters:";

  # Figure out what to stash in the MTA options
  $mtaopts = {};
  if ($config->{'mta'} eq 'sendmail') {
    $mtaopts->{'maintain_config'} = 1
      if $config->{'maintain_mtaconfig'};
    $mtaopts->{'maintain_vut'} = 1
      if $config->{'sendmail_maintain_vut'};
  }

  # Build up the Data hash.
  $data = {
	   'site_password'      => $pw,
	   'install_dir'        => $config->{'install_dir'},
	   'mta'                => $config->{'mta'},
	   'mta_options'        => $mtaopts,
	   'cgi_bin'            => $config->{'cgi_bin'},
	  };

  # Open the site config file
  open SITE, ">$config->{'lists_dir'}/SITE/config.pl"
    or die "Couldn't open site config file $config->{'lists_dir'}/SITE/config.pl: $!";
  dot;

  # Print out the data hash
  print SITE Dumper($data)
    or die "Couldn't populate site config file $config->{'lists_dir'}/SITE/config.pl: $!";
  dot;

  # Close the file
  close SITE;
  dot;

  # Change ownership and permissions
  chown (scalar getpwnam($config->{'uid'}),
	 scalar getgrnam($config->{'gid'}),
	 "$config->{'lists_dir'}/SITE/config.pl")
    or die "Can't chown $config->{'lists_dir'}/SITE/config.pl: $!";
  dot;

  chmod ((0777 & ~oct($config->{'umask'}), "$config->{'lists_dir'}/SITE/config.pl"))
    or die "Can't chmod $config->{install_dir}/majordomo.crontab, $!";

  print ".ok.\n" unless $quiet;
}

# Copy all of the stock response files into their site-wide directory
sub install_response_files {
  my ($gid, $uid);

  print "Installing stock response files:" unless $quiet;

  rcopy("files", "$config->{'lists_dir'}/SITE/files", 1);
  
  $uid = getpwnam($config->{'uid'});
  $gid = getgrnam($config->{'gid'});
  $um  = oct($config->{'umask'});
  rchown($uid, $gid, 0666 & ~$um, 0777 & ~$um,
	 "$config->{'lists_dir'}/SITE/files");
  print "ok.\n" unless $quiet;
}

# Recursively copy one directory to another, not paying attention to
# ownership or permisions.
sub rcopy {
  my $src = shift;
  my $dst = shift;
  my $dot = shift;
  my ($i);

  $src =~ s!/$!!; # Strip trailing slash
  $dst =~ s!/$!!; # Strip trailing slash

  $dh = DirHandle->new($src);
  for $i ($dh->read) {
    next if $i eq '.' || $i eq '..' || $i eq 'CVS';
    if (-d "$src/$i") {
      unless (-d "$dst/$i") {
	mkdir("$dst/$i", 0700)
	  or die "Can't make directory $dst/$i: $!";
	dot if $dot;
      }
      rcopy("$src/$i", "$dst/$i", $dot);
    }
    else {
      cp("$src/$i", "$dst/$i")
	or die "Can't copy to $dst/$i: $!";
      dot if $dot;
    }
  }
}

sub suggest_mta {
  my $dom   = shift;
  my $nhead = shift;
  my $pw;

  # Prompt for the site password if necessary
  $pw = $config->{'site_password'};
  unless ($pw) {
    $pw = get_str($msg4);
    $config->{'site_password'} = $pw;
  }

  my @args = ("$config->{'install_dir'}/bin/mj_shell", "-d", "$dom", "-p",
	      "$pw", "createlist-regen" . ($nhead ? "-noheader" : ''));

#  print "(@args)\n";
  system(@args) == 0 or die "Error executing $args[0], $?";
}

sub make_alias_symlinks {
  my $dom = shift;
  my $dir = shift;

  symlink("$config->{lists_dir}/ALIASES/mj-alias-$dom", "$dir/mj-alias-$dom");

  if ($config->{sendmail_maintain_vut}) {
    symlink("$config->{lists_dir}/ALIASES/mj-vut-$dom", "$dir/mj-vut-$dom");
  }
}

sub suggest_crontab {
  my $dom = shift;
  return <<"EOM";

# Daily and hourly triggers for $dom
0 0 * * * $config->{'install_dir'}/bin/mj_trigger -d $dom -t daily
0 * * * * $config->{'install_dir'}/bin/mj_trigger -d $dom -t hourly
EOM
}

sub safe_mkdir {
  my $dir  = shift;
  my $mode = shift;
  my $uid  = shift;
  my $gid  = shift;
  unless (-d $dir) {
    mkdir $dir, $mode or die "Can't make $dir, $!";
    chown ($uid, $gid, $dir) or die "Can't chown $dir, $!";
    chmod ($mode, $dir) or die "Can't chmod $dir, $!";
  }
}

sub rchown {
  my $uid = shift;
  my $gid = shift;
  my $mod = shift;
  my $dmod = shift;
  my ($dh, $dir);

  for $dir (@_) {
    dot;
    $dir =~ s!/$!!;
    
    $dh = DirHandle->new($dir);
    chown($uid, $gid, $dir) || die("Couldn't chown $dir, $!");
    chmod($dmod, $dir);
    for my $i ($dh->read) {
      next if $i eq '.' || $i eq '..';
      chown($uid, $gid, "$dir/$i") || die("Couldn't chown $dir/$i, $!");
      chmod($mod, "$dir/$i") || die("Couldn't chmod $dir/$i, $!");
      if (-d "$dir/$i") {
	rchown($uid, $gid, $mod, $dmod, "$dir/$i");
      }
    }
  }
}

sub dot () {
  print "." unless $quiet;
}
1;
#
### Local Variables: ***
### cperl-indent-level:2 ***
### End: ***
