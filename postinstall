# Post-installation script for Majordomo

# Basic functions:
#   1. Create the list hierarchy if necessary.
#   2. Make sure the permissions and ownerships are proper.
#   3. Convert 1.x lists.
#   (etc.  Perhaps spit out aliases?)

use DirHandle;
use File::Copy "cp";
sub dot ();
# We call mj_shell (which we make sure has the right permissions) to do the
# dirty work; it would be possible to include the routines directly, but
# this makes sure that everything was installed correctly.  It's better to
# bomb here than to let a bad installation slip by.

$config = eval { require ".mj_config" };

die "Can't do postinstall unless Makefile.PL has been run!"
  unless $config;

# We pull some variables from the environment 
$ask   = $ENV{ASK};
$skip  = $ENV{SKIP};
$verb  = $ENV{VERBOSE};
$quiet = $ENV{QUIET};
$| = 1;

# List of script files to be installed.
@sidscripts = (qw(mj_resend mj_shell mj_email mj_confirm));
@scripts = (qw(mj_trigger));

# List of default reply files and subjects to be installed in the GLOBAL
# filespace
%files =
  ('en/ack_denial'	        => 'Denial',
   'en/ack_rejection'	        => 'Rejection',
   'en/ack_stall'	        => 'Stall',
   'en/ack_success'	        => 'Success',
   'en/ack_timeout'	        => 'Timeout',
   'en/faq'			=> 'Default faq reply',
   'en/file_sent'		=> 'File has been sent',
   'en/info'			=> 'Info',
   'en/intro'			=> 'Intro',
   'en/welcome'			=> 'Welcome',
   'en/inform'			=> '$UREQUEST $LIST',
   'en/repl_consult'		=> 'Default consult mailreply file',
   'en/repl_confirm'		=> 'Default confirm mailreply file',
   'en/repl_confcons'		=> 'Default confirm+consult mailreply file',
   'en/repl_chain'		=> 'Default chained mailreply file',
   'en/repl_deny'		=> 'Default denial replyfile',
   'en/repl_forward'		=> 'Default forward replyfile',
   'en/request_response'        => 'Automated response from $REQUEST',
   'en/subscribe_to_self'	=> 'Attempt to subscribe $LIST to itself',
   'en/token_reject'		=> 'Rejected token $TOKEN',
   'en/token_reject_owner'      => 'Token rejected by $REJECTER',
   'en/token_remind'            => 'REMINDER from $LIST',
   'en/help/default'   	        => 'Default help file',
   'en/help/commands'		=> 'Overview of available commands',
   'en/help/parser'		=> 'Information about the text parser',
   'en/help/subscribe'		=> 'Help on subscribing',
   'en/help/topics'		=> 'Available help topics',
   'en/help/admin_commands'	=> 'Overview of available administrative commands',
   'en/help/admin_configuration'=> 'Overview of configuration variables and methods',
   'en/help/admin_passwords'	=> 'Information on Majordomo security and passwords',
  );

if ($config->{cgi_bin}) {
  $files{'en/confirm'} = 'CONFIRM from $LIST';
  $files{'en/consult'} = 'CONSULT from $LIST';
}
else {
  $files{'en/confirm'} = ['CONFIRM from $LIST', 'en/confirm_noweb'];
  $files{'en/consult'} = ['CONSULT from $LIST', 'en/consult_noweb'];
}

# These have to be ordered...
@dirs =
  ('stock'         => 'Majordomo-supplied files',
   'stock/en'	   => 'English',
   'stock/en/help' => 'Help files',
   'spool'         => 'Spooled files',
   'public'        => 'Public files',
  );

$msg0 = <<EOM;

Your global password must be known for some of the installation process,
 but it is insecure to store it anywhere outside of Majordomo.  Thus you
 must enter it now.  If you have not yet set a password, choose one and
 enter it below.

What is the global password for domain \$DOM?
EOM

$msg0s = <<EOM;

What is the global password for domain \$DOM?
EOM

$msg1 = <<EOM;

Majordomo stores its lists in a hiearachy of directories.  These can be
 created for you now.  The various list files will be created as needed.
 If you do not answer yes, and the necessary directories do not already
 exist, the rest of the installation will fail.

Create directories?
EOM

$msg2 = <<EOM;

The installation can do some basic global configuration using the questions
 answered before installation began.

If you do not do this, the rest of the installation may not proceed
 correctly, since the global password needs to be set in order for this
 program to make configuration changes.

Do basic global configuration now?
EOM

$msg3 = <<EOM;

Majordomo stores response files (the confirmation message, the various help
 texts, etc.) separately instead of placing them into the program code.
 These files must be installed into the Majordomo system.  Note that these
 go into a special file area and will not overrwite any response files
 which have been uploaded.

Install response files?
EOM

set_script_perms(\@sidscripts, \@scripts);

if ($config->{cgi_bin}) {
  copy_file('mj_confirm', "$config->{install_dir}/bin",
	    $config->{cgi_bin}, $config->{cgi_link});
}

# Create list directories and such
if (!$skip && (!$ask || get_bool($msg1))) {
  create_dirs($config->{'lists_dir'},
	      scalar getpwnam($config->{'uid'}),
	      scalar getgrnam($config->{'gid'}),
	      $config->{'umask'},
	      $config->{'domains'},
	      $config->{'tmpdir'},
	     );
}

# Configure a few global parameters
if (!$skip && (!$ask || get_bool($msg2))) {
  for my $i (@{$config->{'domains'}}) {
    do_config($i);
  }
}

# Convert lists if desired

# Install response files
if (!$skip && (!$ask || get_bool($msg3))) {
  for my $i (@{$config->{'domains'}}) {
    install_response_files($i, $config->{'domain'}{$i}{'password'},
			   \%files, \@dirs);
  }
}

# Give some basic MTA configuration
if (!$skip && -t STDIN) {
  print "\nSome basic configuration information:\n";
  my $nhead = 0;
  for my $i (@{$config->{'domains'}}) {
    suggest_mta($i, $nhead);
    $nhead = 1;
  }
}

if (!$skip && !$quiet && -t STDIN) {
  print <<"EOM";

You may also wish to add the following entries to the $config->{'uid'}
account\'s crontab:
EOM
}
open OUT, ">$config->{install_dir}/majordomo.crontab" or
  die "Can't open sample crontab file, $!";
print OUT <<EOM;
# This is a set of sample crontab entries.
EOM
  
my $ct;
for my $i (@{$config->{'domains'}}) {
  $ct = suggest_crontab($i);
  print $ct if -t STDIN && (!$skip && !$quiet);
  print OUT $ct;
}

close OUT;
chown (scalar getpwnam($config->{'uid'}),
       scalar getgrnam($config->{'gid'}),
       "$config->{install_dir}/majordomo.crontab") or
  die "Can't chown $config->{install_dir}/majordomo.crontab, $!";
chmod (0755, "$config->{install_dir}/majordomo.crontab") or
  die "Can't chmod $config->{install_dir}/majordomo.crontab, $!";

exit;

# Copies or links a file from one directory to another, preserving
# ownership and permissions.
sub copy_file {
  my $script = shift;
  my $source = shift;
  my $dest   = shift;
  my $link   = shift;

  if ($link) {
    link "$source/$script", "$dest/$script" ||
      die "Can't make link in $dest, $!.";
  }
  else {
    cp("$source/$script", "$dest/$script") ||
      die "Can't copy $source/$script to $dest/$script, $!.";
    # Set the owner and mode on the copied file
    chown((stat("$source/$script"))[4,5], "$dest/$script");
    chmod((stat(_))[2], "$dest/$script");
  }
}

sub set_script_perms {
  my $sidscripts = shift;
  my $scripts    = shift;
  print "Setting permissions:" unless $quiet;
  $id = $config->{'install_dir'};
  if ($config->{wrappers}) {
    for my $i (@$sidscripts) {
      push @$scripts, ".$i";
    }
  }
  map {$_ = "$id/bin/$_" unless /\//} @$sidscripts, @$scripts;

  $uid = getpwnam($config->{'uid'});
  $gid = getgrnam($config->{'gid'});

  # Properly set ownerships on everything.
  chown($uid, $gid, @$sidscripts, @$scripts) || die "Couldn't change ownership: $!";
  dot;
  chown($uid, $gid, $id);dot;
  rchown($uid, $gid, 0644, 0755, "$id/bin", "$id/man", "$id/lib");dot;

  # Make executables setuid; the scripts must be readable while the the
  # wrappers need only be executable.
  if ($config->{'wrappers'}) {
    chmod(06111, @$sidscripts) || die "Couldn't change mode: $!";
  }
  else {
    chmod(06555, @$sidscripts) || die "Couldn't change mode: $!";
  }
  dot;
  chmod(0555, @$scripts);dot;
  print "ok\n" unless $quiet;
}

sub create_dirs {
  my $l    = shift;
  my $uid  = shift;
  my $gid  = shift;
  my $um   = shift;
  my $doms = shift;
  my $tmp  = shift;
  my($i);

  print "Making directories:" unless $quiet;
  print "$l, $tmp, $uid, $gid\n" if $verb;

  safe_mkdir($l,           0777 & ~oct($um), $uid, $gid);dot;
  safe_mkdir($tmp,         0777 & ~oct($um), $uid, $gid);dot;
  safe_mkdir("$tmp/locks", 0777 & ~oct($um), $uid, $gid);dot;
  
  for $i (@$doms) {
    printf "Making directories for %s, mode %lo.\n", $i, (0777 & ~oct($um))
      if $verb;
    safe_mkdir("$l/$i", 0777 & ~oct($um), $uid, $gid);dot;
    safe_mkdir("$l/$i/GLOBAL", 0777 & ~oct($um), $uid, $gid);dot;
    safe_mkdir("$l/$i/GLOBAL/files", 0777 & ~oct($um), $uid, $gid);dot;
    safe_mkdir("$l/$i/GLOBAL/sessions", 0777 & ~oct($um), $uid, $gid);dot;
  }
  print "ok.\n" unless $quiet;
}

# Set basic config vars
sub do_config {
  my $dom = shift;
  # Do everything from the global $config
  my(@args, $arg, $i, $ignore, $msg, $pw);

  # Prompt for the password if necessary
  $pw = $config->{'domain'}{$dom}{'master_password'};
  unless ($pw) {
    ($msg = $msg0) =~ s/\$DOM/$dom/;
    $pw = get_str($msg);
    $config->{'domain'}{$dom}{'master_password'} = $pw;
    $msg0 = $msg0s; # Switch to using the short prompt.
  }
  print "Configuring $dom:" unless $quiet;

  # Build the command line
  @args = ("$config->{'install_dir'}/bin/mj_shell", "-d", "$dom", "-F",
	   "$config->{wtmpdir}/inst.$$");

  # Build the command file
  open FILE, ">$config->{wtmpdir}/inst.$$";
  print FILE "approve GLOBAL.pass configset GLOBAL master_password = $pw\n";
  print FILE "default password $pw\n";
  for $i (qw(tmpdir site_name whoami install_dir lists_dir mta)) {
    $arg = $config->{'domain'}{$dom}{$i} || $config->{$i};
    print FILE "configset GLOBAL $i = $arg\n";
  }
  print FILE "configset GLOBAL whereami = $dom\n";
  close FILE;
  # Make sure the file can be read by the Majordomo user.  XXX This is a
  # slight security hole.  We're root, so we should play with chowning the
  # file.
  chmod(0644, "$config->{wtmpdir}/inst.$$");dot;

  print "\nDo not be alarmed if the first command fails.\n\n@args\n" if $verb;

#  system(@args) == 0 or die "Error executing $args[0], $?";
  $cmdline = join(' ', @args);
  open SHELL, "$cmdline|" or die "Error executing $args[0], $?";
  while (<SHELL>) {
    print if $verb;
    dot if />>>> / && !$verb;
  }
  close SHELL;
  unlink "$config->{wtmpdir}/inst.$$";
  print "ok.\n" unless $quiet;
}

sub install_response_files {
  my $dom   = shift;
  my $pass  = shift;
  my $files = shift;
  my $dirs  = shift;
  my(@args, @dirs, $dir, $file, $i, $subj);

  # Grab the password if necessary
  $pw = $config->{'domain'}{$dom}{'master_password'};
  unless ($pw) {
    ($msg = $msg0) =~ s/\$DOM/$dom/;
    $pw = get_str($msg);
    $config->{'domain'}{$dom}{'master_password'} = $pw;
    $msg0 = $msg0s; # Switch to using the short prompt.
  }
  print "Installing response files for $dom:" unless $quiet;

  # Copy dirs so we don't destroy the original array
  @dirs = @$dirs;

  @args = ("$config->{'install_dir'}/bin/mj_shell", "-d", "$dom", "-F",
	   "$config->{wtmpdir}/inst.$$");

  # Build the command file
  open FILE, ">$config->{wtmpdir}/inst.$$";
  print FILE "default password $pw\n";
  # Make the directories
  while (($dir, $subj) = splice(@dirs, 0, 2)) {
    print FILE "put=dir GLOBAL /$dir $subj\n";
  }
  # Put the files
  $i = 1;
  while (($file, $subj) = each %{$files}) {
    if (ref($subj)) {
      print FILE "put GLOBAL /stock/$file $$subj[0] <\@$i\n";
      # Copy each file into the temp area, so Majordomo can read it.
      cp("files/$$subj[1]", "$config->{wtmpdir}/inst.$$.$i");
    }
    else {
      print FILE "put GLOBAL /stock/$file $subj <\@$i\n";
      cp("files/$file", "$config->{wtmpdir}/inst.$$.$i");
    }
    chmod(0644, "$config->{wtmpdir}/inst.$$.$i");
    push @args, ("-f", "$config->{wtmpdir}/inst.$$.$i");
    $i++;
  }
  close FILE;
  chmod(0644, "$config->{wtmpdir}/inst.$$");

  # Now run the generated command line, piping the output back to us so we
  # can hide it from the user.
  $cmdline = join(' ', @args);
  print "$cmdline\n" if $verb;
  open SHELL, "$cmdline|" or die "Error executing $args[0], $?";
  while (<SHELL>) {
    print if $verb;
    dot if />>>> / && !$verb;
  }
  close SHELL;

  # Now clean up all of those temporary files we made.
  unlink "$config->{wtmpdir}/inst.$$";
  while ($i > 0) {
    unlink "$config->{wtmpdir}/inst.$$.$i";
    $i--;
  }
  print "ok.\n" unless $quiet;
}

sub suggest_mta {
  my $dom   = shift;
  my $nhead = shift;
  my $pw;

  $pw = $config->{'domain'}{$dom}{'master_password'};
  unless ($pw) {
    ($msg = $msg0) =~ s/\$DOM/$dom/;
    $pw = get_str($msg);
    $config->{'domain'}{$dom}{'master_password'} = $pw;
    $msg0 = $msg0s; # Switch to using the short prompt.
  }

  my @args = ("$config->{'install_dir'}/bin/mj_shell", "-d", "$dom", "-p",
	      "$pw", "createlist=nocreate,quiet" . ($nhead ? ",noheader" :
	      ''), "GLOBAL");

#  print "(@args)\n";
  system(@args) == 0 or die "Error executing $args[0], $?";
}

sub suggest_crontab {
  my $dom = shift;
  return <<"EOM";

# Daily and hourly triggers for $dom
0 0 * * * $config->{'install_dir'}/bin/mj_trigger -d $dom -t daily
0 * * * * $config->{'install_dir'}/bin/mj_trigger -d $dom -t hourly
EOM
}

  

sub get_str {
  return prompt(shift, shift);
}

sub get_bool {
  my ($msg, $def) = @_;
  chomp $msg;
  my $val = prompt($msg, $def ? "yes" : "no");
  $val =~ /^y/i ? 1:0;
}

sub prompt ($;$) {
  my($mess,$def)=@_;
  my $ISA_TTY = -t STDIN && -t STDOUT ;
  Carp::confess("prompt function called without an argument") unless defined $mess;
  my $dispdef = defined $def ? "[$def] " : " ";
  $def = defined $def ? $def : "";
  my $ans;
  if ($ISA_TTY) {
    local $|=1;
    print "$mess $dispdef->";
    chomp($ans = <STDIN>);
  }
  return $ans || $def;
}
	    
sub safe_mkdir {
  my $dir  = shift;
  my $mode = shift;
  my $uid  = shift;
  my $gid  = shift;
  unless (-d $dir) {
    mkdir $dir, $mode or die "Can't make $dir, $!";
    chown ($uid, $gid, $dir) or die "Can't chown $dir, $!";
    chmod ($mode, $dir) or die "Can't chmod $dir, $!";
  }
}

sub rchown {
  my $uid = shift;
  my $gid = shift;
  my $mod = shift;
  my $dmod = shift;
  my ($dh, $dir);

  for $dir (@_) {
    dot;
    $dir =~ s!/$!!;
    
    $dh = DirHandle->new($dir);
    chown($uid, $gid, $dir) || die("Couldn't chown $dir, $!");
    chmod($dmod, $dir);
    for my $i ($dh->read) {
      next if $i eq '.' || $i eq '..';
      chown($uid, $gid, "$dir/$i") || die("Couldn't chown $dir/$i, $!");
      chmod($mod, "$dir/$i") || die("Couldn't chmod $dir/$i, $!");
      if (-d "$dir/$i") {
	rchown($uid, $gid, $mod, $dmod, "$dir/$i");
      }
    }
  }
}

sub dot () {
  print "." unless $quiet;
}
1;
#
### Local Variables: ***
### mode:cperl ***
### cperl-indent-level:2 ***
### End: ***
