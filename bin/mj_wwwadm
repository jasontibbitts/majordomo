#!/usr/local/bin/perl-latest -wT
BEGIN {
  $::LIBDIR = 'unset';
  $::LISTDIR= 'unset';
  $::TMPDIR = 'unset';
  $::LOCKDIR= "blah";
  $::UMASK  = "007";
  $SIG{__WARN__} = sub {print STDERR "--== $_[0]"};

  # Redirect standard error output.
  if (! -t STDERR) {
    open (STDERR, ">>$::TMPDIR/mj_wwwadm.debug");
  }
}

=head1 NAME

mj_wwwadm - demonstration of majordomo administration via the WWW.

=head1 SYNOPSIS

 The command "configshow GLOBAL wwwadm_url" will display the URL.

=head1 DESCRIPTION

When utilizing majordomo with a CGI script, there are
several basic steps that must be taken, including initializing
majordomo variables,  creating a log (STDERR by default), 
initializing a CGI object, and starting a majordomo session
with connect().

=cut
use lib "$::LIBDIR";
use strict;
use CGI;
use Majordomo;
use Mj::Addr;
use Mj::CommandProps qw(:command :function);
use Mj::Format;
use Mj::Log;
use Mj::Parser;

my (%commands, %seen, @domains, @extra, @hereargs, @lists, @mlists, 
    @settings, @values, $addr, $cgi, $cgidata, $cgiurl, $domain, 
    $falseuser, $fh, $func, $i, $j, $line, $list, $mess, $mode, 
    $mj, $ofunc, $ok, $opass, $passw, $pathinfo, $raw, $req, $request, 
    $result, $sess, $str, $sublist, $subs, $tmp, $token, $truelist, 
    $user);

#----- Which commands are supported ?  -----#
# First value:  Is a list required?
# Second value: Should the result be preformatted?
# Third value:  Page to display after the result.
%commands = (   
                'accept'        => [0, 0, 'showtokens'],
                'archive'       => [1, 0, 'command'],
                'configdef'     => [1, 0, 'configshow'],
                'configset'     => [1, 0, 'configshow'],
                'configshow'    => [1, 0, 'configshow'],
                'createlist'    => [0, 0, 'newlist'],
                'digest'        => [1, 1, 'lists'],
                'faq'           => [1, 0, 'lists'],
                'get'           => [1, 0, 'lists'],
                'help'          => [0, 0, 'help'],
                'index'         => [1, 1, 'lists'],
                'info'          => [1, 0, 'lists'],
                'intro'         => [1, 0, 'lists'],
                'lists'         => [0, 0, 'lists'],
                'put'           => [1, 0, 'lists'],
                'register'      => [1, 0, 'who'],
                'reject'        => [0, 0, 'showtokens'],
                'report'        => [1, 1, 'command'],
                'sessioninfo'   => [0, 0, 'showtokens'],
                'set'           => [1, 0, 'who'],
                'showtokens'    => [1, 0, 'showtokens'],
                'subscribe'     => [1, 0, 'who'],
                'tokeninfo'     => [0, 0, 'showtokens'],
                'unregister'    => [1, 0, 'who'],
                'unsubscribe'   => [1, 0, 'who'],
                'which'         => [1, 0, 'which'],
                'who'           => [1, 0, 'who'],
            );

#----- Initialize the Log -----#
&initialize_log;

#----- Initialize the CGI object -----#
$cgi = new CGI;

#----- Obtain domain and list names  -----#
$pathinfo = '';
$domain = $cgi->param('domain') || '';

if (exists $ENV{'PATH_INFO'}) {
  $pathinfo = $ENV{'PATH_INFO'};
  while ($pathinfo =~ s#/domain=([^/]+)##) {
    $tmp = $1;
    next if ($tmp =~ /[^a-zA-Z0-9.-]/);
    # Use the first domain found.
    $domain = $tmp unless (length $domain);
  }

  $pathinfo =~ s#^/+##;
  $pathinfo =~ s#/+$##;
  if ($pathinfo =~ m#([\w/.-]+)#) {
    $pathinfo = $1;
  }
  else {
    $pathinfo = '';
  }
 
  # Multiple lists in the path allow confirmation tokens for multiple
  # lists to be viewed at once with the showtokens command.
  @mlists = split '/', $pathinfo;
}

# Clean up the URL by which this program was invoked.
$cgiurl = $cgi->script_name;
if ($domain) {
  $cgiurl .= "/domain=$domain";
}
if ($pathinfo) {
  $cgiurl .= "/$pathinfo";
}
$cgiurl = Mj::Format::uescape($cgiurl);

unless ($domain) {
  @domains = Majordomo::domains($::LISTDIR);
  ($domain) = grep { lc $_ eq lc $ENV{'HTTP_HOST'} } @domains;
  $domain = $domains[0] unless $domain;
}

# Untaint the domain name.
if ($domain =~ /([a-zA-Z0-9\.\-]+)/) {
  $domain = $1;
}
else {
  &surrender($cgi, qq("$domain" is an invalid domain.), $domain);
}

#----- Make the Majordomo object -----#
$mj = new Majordomo $::LISTDIR, $domain;
&surrender($cgi, $mj, $domain) unless (ref $mj);

#----- Generate the session information. -----#
for my $i ('HTTP_HOST', 'REMOTE_ADDR','REMOTE_PORT', 'PATH_INFO') {
  $sess .= "X-$i: $ENV{$i}\n" if defined $ENV{$i};
}
$sess .= "Date: " . scalar(localtime(time)) . "\n";

#----- Determine the address of the user. -----#
$falseuser = "y$ENV{'REMOTE_ADDR'}\@example.com";
$user      = $cgi->param('user') || $falseuser;

$ofunc   = $cgi->param('func') || 'welcome';
@lists   = $cgi->param('list');
if ((! @lists) and @mlists) {
  @lists = @mlists;
}
$lists[0] ||= '';

#----- Determine what service was requested -----#
# Extract "mode" from command name
if ($ofunc =~ /([^\s=-]+)[=-](.*)/) {
  $func = $1;
  $mode = lc $2;
}
else { 
  $ofunc =~ /(.*)/; $ofunc = $1;
  $func = $ofunc;
  $mode = '';
}

#----- Determine the adminstrative password -----#
$opass = $passw = $cgi->param('passw') || '';
if (length $opass) {
  $opass =~ /(\S+)/; $passw = $1;
}

#----- Connect to the server -----#
($ok, $mess) = $mj->connect('wwwadm', $sess, $user, $passw);
unless ($ok) {
  &surrender($cgi, $mess, $domain);
}

#----- Initialize the variable substitutions -----#
$cgidata = Mj::Format::cgidata($mj, { 'user' => $user, 
                                      'password' => $passw });

$subs = { $mj->standard_subs($lists[0]),
          'CGIDATA'   => $cgidata,
          'CGIURL'    => $cgiurl,
          'CHUNKSIZE' => Mj::Format::escape($cgi->param('chunksize') || ''),
          'CMDPASS'   => '',
          'COMMAND'   => Mj::Format::escape($ofunc),
          'EXTRA'     => '',
          'USER'      => ($user =~ /example.com$/) ? '' : 
                         Mj::Format::escape($user),
        };

@extra = $cgi->param('extra');
if (defined $extra[0]) {
  $subs->{'EXTRA'} = Mj::Format::escape($extra[0]);
}


#----- Remove the temporary password if the admin is signing out. -----#
if ($ofunc eq 'logout') {
  $mj->del_latchkey($passw) if ($mj->t_recognize($passw));
  $subs->{'CMDPASS'} = '';
  $subs->{'COMMAND'} = 'welcome';
  $cgidata = Mj::Format::cgidata($mj, 
               { 
                 'user' => ($user eq $falseuser) ? '' : $user,
                 'password' => '',
               });
  $subs->{'CGIDATA'} = $cgidata;
}
else {
  $passw = $mj->gen_latchkey($passw) 
    if ($passw and !$mj->t_recognize($passw));
  $subs->{'CMDPASS'} = Mj::Format::escape($passw);
  $cgidata = Mj::Format::cgidata($mj, 
               { 
                 'user' => ($user eq $falseuser) ? '' : $user,
                 'password' => $passw,
               });
  $subs->{'CGIDATA'} = $cgidata;
}

#----- Should the header and footer be displayed? -----#
$raw = 0;
if (($func eq 'tokeninfo' and $mode =~ /part/ 
     and $mode !~ /delete|edit|replace/) or 
    ($func eq 'archive' and $mode =~ /get/ and $mode =~ /part/))
{
  $raw = 1;
}

#----- Print the generic page header -----#
unless ($raw) {
  print $cgi->header('-expires' => '+50s');
  if ($lists[0] =~ /^(ALL|DEFAULT|GLOBAL)/) {
    $tmp = $mj->format_get_string('wwwadm', 'head_global');
  }
  else {
    $tmp = $mj->format_get_string('wwwadm', 'head');
  }
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";
}

@extra = $cgi->param('extra');

if ($ofunc eq 'logout') {
  &usage($mj, $subs, 'You have successfully signed out.', '');
}

unless (length $lists[0]) {
  &login($mj, $subs, '');
}

#----- Validate the list names -----#
for ($i = 0 ; $i < scalar @lists ; $i++) {
  $lists[$i] =~ s/\s+//g;
  unless (Majordomo::legal_list_name($lists[$i])) {
    &login($mj, $subs, qq("$lists[$i]" is an invalid list name.));
  }
}
for $i (@mlists) {
  unless (Majordomo::legal_list_name($i)) {
    &login($mj, $subs, qq("$i" is an invalid list name.));
  }
}

($truelist, $sublist, $mess) = $mj->valid_list($lists[0], 1, 1);
unless ($truelist) {
  $subs->{'USER'} ||= Mj::Format::escape($user);
  &login($mj, $subs, $mess);
}
unless ($passw) {
  &login($mj, $subs, '');
}

$addr = new Mj::Addr($user);

if (! defined $addr) {
  ($ok, $mess) = (0, "The address is undefined.");
}
else {
  ($ok, $mess) = $addr->valid;
}

unless ($ok) {
  &login($mj, $subs, qq(The address "$user" is invalid.\n$mess\n));
}

if ($ofunc =~ /newfaq|newinfo|newintro/) {
  $func = "put";
}

unless ($mj->validate_passwd($addr, $passw, $truelist, 'ANY')) {
  $subs->{'CMDPASS'} = '';
  if ($mj->t_recognize($opass)) {
    &login($mj, $subs, '');
  }

  $tmp = $mj->format_error('invalid_password', $truelist, 'VICTIM' => $user);

  # Record password failures in the log.
  $mj->inform('GLOBAL', 'connect', $user, $user, 
              "(wwwadm request from $ENV{'REMOTE_ADDR'})",
              'wwwadm', 0, 0, 0, $tmp, $::log->elapsed);

  &login($mj, $subs, $tmp);
}

if ($ofunc eq 'newlist') {
  &newlist($mj, $subs, '')
}
elsif ($ofunc eq 'login') {
  &login($mj, $subs, '');
}
elsif ($ofunc eq 'welcome') {
  $tmp = $cgi->param('doc') || '';
  &usage($mj, $subs, '', $tmp);
}
elsif ($ofunc eq 'command') {
  &command($mj, $subs, '');
}
elsif (! exists $commands{$func}) {
  &usage($mj, $subs, "$func is an unsupported command.", '');
}

# The archive-get and get commands must use immediate mode,
# to display the results instead of mailing them.
if (($func eq 'archive' and $mode =~ /get/ and $mode !~ /part/) 
    or ($func eq 'get' and $mode !~ /edit/)) {
  $mode .= $mode? "-immediate" : "immediate";
}
elsif ($func eq 'who' and $mode !~ /enhanced/) {
  $mode .= $mode? "-enhanced" : "enhanced";
}

#----- Password check -----#
if (! $passw) {
  &usage($mj, $subs, 
         "A password is required to use the $func command.", '');
}

#----- List check -----#
if ($commands{$func}->[0] and ! scalar @lists) {
  &usage($mj, $subs, 
   "A mailing list must be provided to use the \"$func\" command.", '');
}

no strict 'refs';

$request = {
    'cgidata'   => $cgidata,
    'cgiurl'    => $cgiurl,
    'command'   => $func,
    'list'      => $truelist,
    'sublist'   => $sublist,
    'mode'      => $mode,
    'password'  => $passw, 
    'user'      => $addr,
};

# Deal with result sets
if ($func eq 'who' or $func eq 'which') {
  $request->{'chunksize'} = $cgi->param('chunksize') || 0;
  $request->{'start'} = $cgi->param('start') || 1;
}

if (function_prop($func, 'iter')) {
  $request->{'command'} .= '_start';
}


#----- Process command arguments -----#
# Normally, the "extra" variable is used to hold command arguments.
# However, there are some cases in which this approach is inadequate.
#
# The first is with the configset command, in the case that more
# than one setting is changed at once.
#
# The second exception is for the subscribe-set command, which
# must have both addresses and settings available.
#
# The third exception is for the accept and reject commands,
# which must allow an explanation to be sent back to the person
# whom the command affects.
#
# The fourth exception is for the set command, which must include
# separate settings for each address affected.
#
# The fifth exception is for the report command, which must include
# separate action and time span values.
#
# The sixth exception is for the configshow command, which allows
# an array of variables to be specified.
#
# The seventh exception is for the who or which command, which must
# include a search pattern.
#
# The eighth exception is for the createlist command, which
# can include a group of list owners, a password, and possibly
# a new list name.
#
# In each of these cases, the basic command form requires that the
# "extra" variable still be handled if it was used.
if (@extra and $func ne 'showtokens') {
  $i = 0;
  for $req (@extra) {
    $i++;
    Mj::Parser::parse_args($request, $req, '');

    # Deal with accept/reject reasons and other values from textareas.
    if ($func =~ /accept|reject/) {
      $request->{'xplanation'} ||= $cgi->param('xplanation');
    }
    elsif ($func eq 'configset' and not $cgi->param('command')) {
      @values = $cgi->param($req);
      @values = split ("\r?\n", $values[0]) unless ($#values);
      $request->{'value'} = [@values];
    }
    elsif ($mode =~ /replace/) {
      @values = split "\r?\n", $cgi->param('contents');
      $request->{'contents'} = [@values];
    }

    $result = $mj->dispatch($request); 

    if ($raw and $i == 1) {
      if (! $result->[0] or 
          ($func eq 'archive' and ! $request->{'part'}))
      {
        print $cgi->header('-expires' => '+50s');
        if ($request->{'list'} =~ /^(ALL|DEFAULT|GLOBAL)/) {
          $tmp = $mj->format_get_string('wwwadm', 'head_global');
        }
        else {
          $tmp = $mj->format_get_string('wwwadm', 'head');
        }
        $str = $mj->substitute_vars_format($tmp, $subs);
        print STDOUT "$str\n";
        $raw = 0;
      }
      elsif ($request->{'part'} =~ /[hH]$/) {
        print $cgi->header('-type' => 'text/plain',
                           '-expires' => '+50s');
      }
      else {
        if ($func eq 'tokeninfo' and ! $request->{'part'}) {
          $tmp = 'text/plain';
        }
        elsif ($func eq 'tokeninfo') {
          $tmp = $result->[2]->{$request->{'part'}}->{'type'} || 'text/plain';
        }
        else {
          $tmp = $result->[1]->[2]->{$request->{'part'}}->{'type'} 
            || 'text/plain';
        }

        print $cgi->header('-type' => $tmp, 'expires' => '+50s');
      }
    }

    &usage($mj, $subs, "Unable to obtain result from Majordomo.", '') 
      unless $result;

    print "<pre>\n" if ($commands{$func}->[1]);
    &{"Mj::Format::$func"}($mj, \*STDOUT, \*STDOUT, 'wwwadm', $request, $result);
    print "</pre>\n" if ($commands{$func}->[1]);;

    if (function_prop($func, 'iter')) {
      $request->{'command'} =~ s/done/start/;
    }
  }
}
elsif ($func eq 'set') {
  @extra = $cgi->param('victims');
  unless (scalar @extra) {
    &usage($mj, $subs, $mj->format_error('no_address', $list));
  }
  for $addr (@extra) {
    @values = $cgi->param($addr);
    $request->{'setting'} = join ",", @values;
    for $j (qw(ackdeny ackpost ackreject ackstall eliminatecc hideaddress
               hideall hidepost postblock prefix replyto selfcopy rewritefrom)) {
      unless (grep { $_ eq $j } @values) {
        $request->{'setting'} .= ",no$j";
      }
    }
    $request->{'victims'} = [ $addr ];
    $result = $mj->dispatch($request); 
    &usage($mj, $subs, "Unable to obtain result from Majordomo.", '') 
      unless $result;
    print "<pre>\n" if ($commands{$func}->[1]);
    &{"Mj::Format::$func"}($mj, \*STDOUT, \*STDOUT, 'wwwadm', $request, $result);
    print "</pre>\n" if ($commands{$func}->[1]);;
  }
}
# The remaining exceptions, other than showtokens, require only one dispatch call.
elsif ($func ne 'showtokens') {
  if ($func eq 'accept' or $func eq 'reject') {
    @extra = $cgi->param('tokens');
    $request->{'tokens'} = [ @extra ];
    $request->{'xplanation'} = join "\n", $cgi->param('xplanation');
  }
  elsif ($func eq 'subscribe' or $func eq 'unsubscribe' 
         or $func eq 'register' or $func eq 'unregister') 
  {
    @extra = $cgi->param('victims');
    unless (scalar @extra) {
      &usage($mj, $subs, $mj->format_error('no_address', $list));
    }
    if (scalar @extra == 1) {
      @extra = split "\r?\n", $extra[0];
    }
    $request->{'victims'} = [ @extra ];
    if ($func eq 'subscribe' and $mode =~ /set/) {
      @extra = $cgi->param('setting');
      $request->{'setting'} = join ',', @extra;
      for $j (qw(ackdeny ackpost ackreject ackstall eliminatecc hideaddress
                 hideall hidepost postblock prefix replyto selfcopy 
                 rewritefrom)) 
      {
        unless (grep { $_ eq $j } @extra) {
          $request->{'setting'} .= ",no$j";
        }
      }
    }
    elsif ($func eq 'subscribe' and scalar @extra == 1) {
      $tmp = $cgi->param('name');
      if (defined $tmp and $tmp =~ /\S/) {
        $addr = new Mj::Addr($extra[0]);
        ($ok, $mess) = $addr->setcomment($tmp);
        unless ($ok) {
          &login($mj, $subs, "The name $tmp is invalid.\n$mess\n");
        }
        $request->{'victims'} = [ $addr ];
      }
    }
  }
  elsif ($func eq 'report') { 
    $request->{'action'} = join ',', $cgi->param('action');
    $request->{'date'} = $cgi->param('date');
  }
  elsif ($func eq 'configshow') {
    $request->{'groups'} = join ',', $cgi->param('groups');
  }
  elsif ($func eq 'who' or $func eq 'which') {
    $request->{'regexp'} = $cgi->param('pattern');
  }
  elsif ($func eq 'put') {
    if ($ofunc eq 'newfaq') {
      $request->{'file'} = '/faq';
      $request->{'xdesc'} = 'Frequently Asked Questions';
    }
    elsif ($ofunc eq 'newinfo') {
      $request->{'file'} = '/info';
      $request->{'xdesc'} = 'List Information';
    }
    elsif ($ofunc eq 'newintro') {
      $request->{'file'} = '/intro';
      $request->{'xdesc'} = 'List Introductory Information';
    }
    elsif ($ofunc =~ /^put/ and $cgi->param('args')) {
      Mj::Parser::parse_args($request, $cgi->param('args'), '');
    }
    $tmp = $cgi->param('contents');
    $tmp =~ s/\r?\n$//;
    @extra = split "\r?\n", $tmp;
    $request->{'contents'} = [@extra];
  }
  elsif ($func eq 'createlist') {
    $request->{'newlist'} = $cgi->param('newlist');
    if ($cgi->param('newname')) {
      $request->{'newpasswd'} = $cgi->param('newname');
    }
    elsif ($cgi->param('newpasswd')) {
      unless ($request->{'mode'} =~ /pass/) {
        if (length $request->{'mode'}) {
          $request->{'mode'} .= '-pass';
        }
        else {
          $request->{'mode'} = 'pass';
        }
      }
      $request->{'newpasswd'} = $cgi->param('newpasswd');
    }
    $tmp = $cgi->param('owners');
    $tmp =~ s/\r?\n$//;
    if ($tmp !~ /\S/ and $user =~ /example.com/) {
      &newlist($mj, $subs, "A valid list owner address was not supplied.\n")
        unless ($mode =~ /destroy|nocreate|regen|rename/);
    }
    @extra = split "\r?\n", $tmp;
    $request->{'owners'} = [@extra];
  }
    
  $result = $mj->dispatch($request); 
  &usage($mj, $subs, "Unable to obtain result from Majordomo.", '') 
    unless $result;
  print "<pre>\n" if ($commands{$func}->[1]);
  &{"Mj::Format::$func"}($mj, \*STDOUT, \*STDOUT, 'wwwadm', $request, $result);
  print "</pre>\n" if ($commands{$func}->[1]);;
}

#----- Display supplementary information -----#
# There are seven supplementary screens which this script displays. 
#   command    - Display a command menu
#   configshow - Allow easy access to collections of settings.
#   newlist    - Allow lists to be created, renamed, or destroyed.
#   lists      - Show details about a list, or a collection of lists.
#   showtokens - Display a list of pending requests
#   which      - Search all subscriber lists or (un)register addresses
#   who        - Search the subscriber list or (un)subscribe addresses

$tmp = $cgi->param('command') || '';
if ($cgi->param('brief') or $raw) {
  # do not display supplemental information.
}
elsif (($tmp eq 'on' and $func ne 'showtokens')
    or $commands{$func}->[2] eq 'command') {
  &command($mj, $subs, '');
}
elsif ($commands{$func}->[2] eq 'newlist') {
  &newlist($mj, $subs, '');
}
elsif ($commands{$func}->[2] eq 'showtokens') {
  # A separate head and foot are needed because this interface
  # can display tokens for any number of mailing lists.
  $tmp = $mj->format_get_string('wwwadm', 'showtokens_head');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print "$str\n";

  Mj::Parser::parse_args($request, $extra[0], '')
    if ($func eq 'showtokens' and $extra[0]);
  $i = 0;
  $request->{'command'} = 'showtokens';
  $request->{'mode'} = '';
  my (%seen);
  for $list (@lists, @mlists) {
    next if (exists $seen{$list});
    $request->{'list'} = $list;
    $result = $mj->dispatch($request);
    # Increase the token count if any tokens were found.
    if ($result->[0]) {
      $i += $#$result;
    }
    &{"Mj::Format::showtokens"}($mj, \*STDOUT, \*STDOUT, 'wwwadm', 
                                      $request, $result);
    $seen{lc $list}++;
  }

  $subs->{'COUNT'} = $i;
  $tmp = $mj->format_get_string('wwwadm', 'showtokens_foot');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print "$str\n";

  if ($cgi->param('command') eq 'on' and $func eq 'showtokens') {
    &command($mj, $subs, '');
  }
}
elsif ($commands{$func}->[2] ne $func) {
  if ($commands{$func}->[2] eq 'configshow') {
    $func = $request->{'command'} = 'configshow';
    $request->{'mode'} = 'categories';
    $request->{'list'} = $lists[0];
  }
  elsif ($commands{$func}->[2] eq 'lists') {
    $func = $request->{'command'} = 'lists';
    $request->{'mode'} = 'full-long';
    $request->{'list'} = 'GLOBAL';
    $request->{'regexp'} = $lists[0];
  }
  elsif ($commands{$func}->[2] eq 'who') {
    $func = 'who';
    $request->{'command'} = 'who_start';
    $request->{'mode'} = 'enhanced';
    $request->{'list'} = $lists[0];
    $request->{'chunksize'} = $cgi->param('chunksize') || 20;
    $request->{'start'} = $cgi->param('start') || 1;
    $request->{'regexp'} = $cgi->param('pattern');
    $request->{'victims'} = '';
  }
  elsif ($commands{$func}->[2] eq 'which') {
    $func = 'which';
    $request->{'command'} = 'which';
    $request->{'mode'} = '';
    $request->{'list'} = 'GLOBAL';
    $request->{'chunksize'} = $cgi->param('chunksize') || 20;
    $request->{'regexp'} = $cgi->param('pattern');
    $request->{'victims'} = '';
  }
  $result = $mj->dispatch($request); 
  &usage($mj, $subs, "Unable to obtain result from Majordomo.", '') 
    unless $result;
  &{"Mj::Format::$func"}($mj, \*STDOUT, \*STDOUT, 'wwwadm', $request, $result);
}

#----- Print the Footer -----#
unless ($raw and $result->[0]) {
  if ($request->{'list'} =~ /^(ALL|DEFAULT|GLOBAL)/) {
    $tmp = $mj->format_get_string('wwwadm', 'foot_global');
  }
  else {
    $tmp = $mj->format_get_string('wwwadm', 'foot');
  }
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";
}

#----- Subroutines -----#

sub command {
  my ($mj, $subs, $message) = @_;
  my ($str, $tmp);

  $subs->{'ERROR'} = Mj::Format::escape($message);
  $::log->message(50, "info", $message) if $message;

  $tmp = $mj->format_get_string('wwwadm', 'command');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";

  $tmp = $mj->format_get_string('wwwadm', 'foot');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";
  
  exit 1;
}

sub initialize_log {
  $ENV{'PATH'} = "/bin:/usr/bin:/usr/ucb";

  umask oct($::UMASK);

  # Change the log level to a higher number (600) for complete debugging.
  $::log = new Mj::Log;
  $::log->add
    (
     method      => 'handle',
     id          => 'wwwadm',
     handle      => \*STDERR,
     level       => 50,
     subsystem   => 'mail',
     log_entries => 1,
     log_exits   => 1,
     log_args    => 1,
    );

  $::log->in(20, undef, "info", 
    "Majordomo WWW for List Owners - " . scalar(localtime) .
     " from $ENV{'REMOTE_ADDR'}");

  $::log->startup_time();
}

sub login {
  my $mj = shift; 
  my $subs = shift;
  my $message = shift || '';
  my ($str, $tmp);

  $subs->{'ERROR'} = Mj::Format::escape($message);
  $subs->{'COMMAND'} = "welcome"
   if ($subs->{'COMMAND'} eq "login");

  if ($message) {
    $str = $message . "  Request: $subs->{'COMMAND'}  List: $subs->{'LIST'}";
    $::log->message(50, "info", $message);
  }

  $tmp = $mj->format_get_string('wwwadm', 'login');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";

  $tmp = $mj->format_get_string('wwwadm', 'foot');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";
  
  exit 1;
}

sub newlist {
  my ($mj, $subs, $message) = @_;
  my ($str, $tmp);

  $subs->{'ERROR'} = Mj::Format::escape($message);
  $::log->message(50, "info", $message) if $message;

  $tmp = $mj->format_get_string('wwwadm', 'newlist');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";

  if ($subs->{'LIST'} =~ /^(ALL|DEFAULT|GLOBAL)/) {
    $tmp = $mj->format_get_string('wwwadm', 'foot_global');
  }
  else {
    $tmp = $mj->format_get_string('wwwadm', 'foot');
  }
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";
  
  exit 1;
}

sub usage {
  my ($mj, $subs, $message, $helpfile) = @_;
  my ($str, $tmp);

  $subs->{'ERROR'} = Mj::Format::escape($message);
  $::log->message(50, "info", $message) if $message;

  if (defined $helpfile and length $helpfile) {
    $tmp = $mj->format_get_string('wwwadm', "welcome_$helpfile");
  }
  elsif ($subs->{'LIST'} =~ /^(ALL|DEFAULT|GLOBAL)/) {
    $tmp = $mj->format_get_string('wwwadm', 'welcome_global');
  }
  else {
    $tmp = $mj->format_get_string('wwwadm', 'welcome');
  }
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";

  if ($subs->{'LIST'} =~ /^(ALL|DEFAULT|GLOBAL)/) {
    $tmp = $mj->format_get_string('wwwadm', 'foot_global');
  }
  else {
    $tmp = $mj->format_get_string('wwwadm', 'foot');
  }
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";
  
  exit 1;
}

sub surrender {
  my ($cgi, $message, $domain) = @_;
  my $url = $cgi->script_name;

  if ($message) {
    $::log->message(50, "info", $message);
    $message = Mj::Format::escape($message);
  }

  $domain = Mj::Format::escape($domain);
  
  print $cgi->header(-expires => '+50s');
  print <<EOM;
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
"http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head>
<title>list administration: error</title>
</head>
<body>
<h2 align="center">Majordomo Error</h2>

<pre>$message</pre>

<p>
Type a valid Majordomo domain name into the <b>Domain</b> box.  
Press the <b>Sign In</b> button to receive further instructions.
</p>

<form method="POST" action="$url">
  <input type="hidden" name="func" value="login">
  Domain: 
  <input name="domain" size="45" value="$domain">
  <input type="submit" value="Sign In">
</form>
</body></html>
EOM

  exit 0;
}


=head1 COPYRIGHT

Copyright (c) 2000, 2002 Jason Tibbitts for The Majordomo Development
Group.  All rights reserved.

This program is free software; you can redistribute it and/or modify it
under the terms of the license detailed in the LICENSE file of the
Majordomo2 distribution.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the Majordomo2 LICENSE file for more
detailed information.

=cut

#^L
### Local Variables: ***
### cperl-indent-level:2 ***
### End: ***


