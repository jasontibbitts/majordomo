#!/usr/local/bin/perl-latest -wT
BEGIN {
  $::LIBDIR = 'unset';
  $::LISTDIR= 'unset';
  $::DEFDOM = 'unset';
  $::TMPDIR = 'unset';
  $::LOCKDIR= "blah";
  $::UMASK  = "007";
  $SIG{__WARN__} = sub {print STDERR "--== $_[0]"};

  # Redirect standard error output.
  if (! -t STDERR) {
    open (STDERR, ">>$::TMPDIR/mj_wwwadm.debug");
  }
}

=head1 NAME

mj_wwwadm - demonstration of majordomo administration via the WWW.

=head1 SYNOPSIS

Extend this file to create specialized CGI scripts.

=head1 DESCRIPTION

When utilizing majordomo with a CGI script, there are
several basic steps that must be taken, including initializing
majordomo variables,  creating a log (STDERR by default), 
initializing a CGI object, and starting a majordomo session
with connect().

This script performs these basic steps, easing the 
creation of new CGI scripts.  Extend it to suit your needs.

Note that it may be necessary to install a setuid wrapper
for any script based upon this template.

=cut
use lib "$::LIBDIR";
use strict;
use CGI;
use Majordomo;
use Mj::Format;
use Mj::Parser;
use Mj::CommandProps qw(:command :function);
use Mj::Log;
use Mj::Addr;

my ($cgi, $cgiurl, $domain, $i, $mj, $ok, $mess, $serveradmin, $sess, $token);
my ($ofunc, $func, $user, $passw, $pathinfo, $mode, $list, @lists, $vict, $extra);
my ($line, $st, $file, $fh, $cmdform, $localpart, $request, $req, @extra);
my (%seen, @mlists, $otherlists, $subs, @hereargs);

$ENV{'PATH'} = "/bin:/usr/bin:/usr/ucb";

umask oct($::UMASK);

# Change the log level to a higher number (600) for complete debugging.
$::log = new Mj::Log;
$::log->add
  (
   method      => 'handle',
   id          => 'mjadm',
   handle      => \*STDERR,
   level       => 50,
   subsystem   => 'mail',
   log_entries => 1,
   log_exits   => 1,
   log_args    => 1,
  );

$::log->in(20, undef, "info", 
  "Majordomo WWW Admin - ".scalar(localtime)." from $ENV{'REMOTE_ADDR'}");
$::log->startup_time();

# Start up the page and parse the URL
$cgi = new CGI;
print $cgi->header;
$domain = $cgi->param('domain') || $::DEFDOM;
$domain =~ /(\S+)/; $domain = $1;

# Generate the session information
for my $i ('REMOTE_ADDR','REMOTE_PORT', 'PATH_INFO') {
  $sess .= "$i = $ENV{$i}\n" if defined $ENV{$i};
}
$sess .= scalar(localtime(time)) . "\n";

# Make the Majordomo object
$mj = new Majordomo $::LISTDIR, $domain;
&surrender($mess, $sess) unless (ref $mj);

$serveradmin = $mj->global_config_get(undef, undef, 'whoami_owner');

($ok, $mess) = $mj->connect('mj_wwwadm', $sess);
&surrender($mess, $sess, $serveradmin) unless ($ok);

# $cgiurl = $mj->{'sitedata'}{'config'}{'cgi_url'} . "mj_wwwadm";
# Use the URL with which we were called
$cgiurl = sprintf "http://%s:%s%s", $ENV{'SERVER_NAME'},
          $ENV{'SERVER_PORT'}, $ENV{'SCRIPT_NAME'};

$pathinfo = 'GLOBAL';
if (exists $ENV{'PATH_INFO'}) {
  $cgiurl  .= $ENV{'PATH_INFO'};
  $pathinfo = $ENV{'PATH_INFO'};
  $pathinfo =~ m#/([^/\s]+)#;
  $pathinfo = $1;
}

# Get HTML form variables
$ofunc   = $cgi->param('func') || "help";
$localpart = $ENV{'REMOTE_ADDR'} || "mj_wwwadm";
$localpart =~ /(.*)/; $localpart = $1;
$user    = new Mj::Addr("$localpart\@example.com");
$passw   = $cgi->param('passw') || '';
@lists   = ($pathinfo);
@lists   = $cgi->param('list') if $cgi->param('list');
@mlists  = $cgi->param('mlist');
@extra   = $cgi->param('extra');
@hereargs = split /\r?\n/, join '', $cgi->param('hereargs');
$st      = $cgi->param('st') || '';
if ($st eq 'on' or $st eq 'checked') { $st = 'checked'; }
$extra[0] ||= '';
$extra   = $extra[0];
# Remove duplicates from the list of lists.
@lists   = grep (!$seen{$_}++, @lists, @mlists);

# Generate temporary password for increased security.
if (defined $passw and $passw !~ /^[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}$/) {
  $passw   = $mj->gen_latchkey($passw) if (length $passw);
}

# Extract "mode" from command name
if ($ofunc =~ /([^\s=-]+)[=-](.*)/) {
  $func = $1;
  $mode = $2;
}
else { 
  $ofunc =~ /(.*)/; $ofunc = $1;
  $func = $ofunc;
  $mode = '';
}
$otherlists = '';
for $list (@mlists) {
  $otherlists .= "<input type=hidden name=mlist value=$list>\n";
}

$subs = {
         'CGIURL'   => $cgiurl,
         'DOMAIN'   => $domain,
         'LIST'     => $lists[0],
         'MULTILIST'=> $otherlists,
         'PASSWORD' => $passw,
         'REQUEST'  => $func,
         'ST'       => $st,
        };

($file, undef) = $mj->_list_file_get('GLOBAL', 'wwwadm_head', $subs);

if (! $cgi->param('func') or $func =~ /about/) {
  $::log->message(50, "info",  "Displaying introduction.");
  &usage($mj, $lists[0], $cgiurl, $file);
}

no strict 'refs';
# Make sure the command is valid
unless (command_legal($func)) {
  $mess = "Invalid command $func in form data.";
  $::log->message(50, "info", $mess);
  &surrender($mess, $sess, $serveradmin, $file);
}

# Make sure the list names are valid
for ($i = 0; $i < scalar(@lists); $i++) {
  if ($lists[$i] ne '') {
    unless ($lists[$i] = $mj->valid_list($lists[$i], 1, 1)) {
      $mess = "Invalid list name: $lists[$i]";
      $::log->message(50, "info", $mess);
      &surrender($mess, $sess, $serveradmin, $file);
    }
  }
}

# The archive-get and archive-index commands must use immediate mode,
# to display the results instead of mailing them.
if ($func eq 'archive' or $func eq 'get') {
  $mode .= "-immediate";
}
if ($func eq 'auxwho' or $func eq 'who') {
  $mode .= $mode? "-enhanced" : "enhanced";
}
if ($func eq 'configdef') {
  @hereargs = ();
}

# Verify the password provided, if the command requires one.
if ($passw eq '' and $func !~ /help|lists|accept|reject|tokeninfo/) {
  $mess = "A password is required to use the $func command.";
  $::log->message(50, "info", $mess);
  &surrender($mess, $sess, $serveradmin, $file);
}
elsif ($passw ne '') {
  # Check the password against the requester
  for $i (@lists) {
    $ok = $mj->validate_latchkey($user, $passw, $i, $func);
    if ($ok <= 0) {
      $mess = "The password is invalid or has expired.";
      $::log->message(50, "info", $mess);
      &surrender($mess, $sess, $serveradmin, $file);
    }
  }
}

if ($func eq 'auxadd' or $func eq 'auxremove') {
  # The group and mail address must be specified in 'extra'
  if ($extra !~ /\s/) {
    $mess = "The $func command requires an auxiliary list name and an address.\n";
    $::log->message(50, "info", $mess);
    &surrender($mess, $sess, $serveradmin, $file);
  }
}

$request = {
    'command'   => $func,
    'list'      => $lists[0],
    'mode'      => $mode,
    'password'  => ($func =~ /help|which|lists/)? '' : $passw, 
    'user'      => $user,
    'st'        => $st,
};
if (function_prop($func, 'iter')) {
  $request->{'command'} .= '_start';
}
if (scalar @lists > 1){
  $request->{'mlist'} = \@lists;
}

$fh = new IO::File ">>$file";

unless ($fh) {
  $mess = "Unable to open output file $file.\n";
  $::log->message(50, "info", $mess);
  &surrender($mess, $sess, $serveradmin);
} 
if ($func ne 'showtokens') {
  $fh->print("<pre><small>\n") unless ($func =~ /configshow|tokeninfo|who/);
  for $req (@extra) {
    Mj::Parser::parse_args($request, $req, \@hereargs);
    &{"Mj::Format::$func"}($mj, $fh, $fh, 'html', $request,
      $mj->dispatch($request));
    print $fh "\n";
  }
  $fh->print("</small></pre>\n") unless ($func =~ /configshow|tokeninfo|who/);
}

# If the "show pending requests" button is checked, or if the 
# showtokens command is chosen from the command menu, a list
# of pending requests will appear at the bottom of the screen.
# Unless the command was chosen from the menu, the command
# arguments are not parsed.
if ($passw and ($st eq 'checked' or $func eq 'showtokens') and @lists) {
  # The password may have been omitted earlier.
  $request->{'password'} = $passw;
  $request->{'command'} = 'showtokens';
  # 'action' is also used by the report command.
  delete $request->{'action'} if (exists $request->{'action'});
  Mj::Parser::parse_args($request, $extra[0])
    if ($func eq 'showtokens');

  print $fh <<EOM;
<form method=POST action="$cgiurl">
<input type=submit name=func value="tokeninfo-full">
<input type=submit name=func value="tokeninfo">
<input type=submit name=func value="accept">
<input type=submit name=func value="accept-archive">
<input type=submit name=func value="reject">
<input type=hidden name=domain value="$domain">
<input type=hidden name=passw value="$passw">
<input type=hidden name=st value="$request->{'st'}">
<br>
Choose one or more requests from the following list,
then press one of the buttons.
EOM

  $i = 0;
  for $list (@lists) {
    $request->{'list'} = $list;
    $i += &{"Mj::Format::showtokens"}($mj, $fh, $fh, 'html', $request,
                                      $mj->dispatch($request));
  }

  print $fh "<br>Requests found: $i.<br>\n";
  if ($i > 7) {
  print $fh <<EOM;
<input type=submit name=func value="tokeninfo-full">
<input type=submit name=func value="tokeninfo">
<input type=submit name=func value="accept">
<input type=submit name=func value="accept-archive">
<input type=submit name=func value="reject">
EOM
  }
  print $fh "</form>\n";
}

$fh->print("<hr>For assistance, contact <a href=\"mailto:$serveradmin\">$serveradmin</a>\n");
$fh->close();

&format_print($file);
unlink $file;

$::log->out;
exit 0;

#---------------- Subroutines -----------------#
sub format_print {
  my ($file) = shift; 
  my ($line, $token, $summarize, $hdrs, $remove);
  $summarize = $hdrs = 0;

  $fh = new IO::File "<$file";
  if (! $fh) { 
    print STDOUT "<h3>Unable to get results</h3>\n";
    exit 0;
  }
  while ($fh->read($line, 4096)) {
    print STDOUT $line;
  }
  1;
}

sub Mj::Format::configshow {
  my ($mj, $out, $err, $type, $request, $result) = @_;
  my $log = new Log::In 29, "$type, $request->{'list'}";
  my (@possible, $auto, $ok, $mess, $tag, $varresult, $var, $val, $vardata);
  select $out;

  $ok = shift @$result;
  for $varresult (@$result) {
    ($ok, $mess, $var, $val) = @$varresult;
    if (! $ok) {
      print "Configshow error: $mess\n";
      next;
    }
    $mess = Mj::Format::escape($mess); 
    chomp $mess;
    # Add a link to the help file for this variable
    $mess =~ s#^\s*$var#<a href="$cgiurl?domain=$domain&func=help&extra=configset_$var">$var</a><small>#;
    print "<pre>\n$mess</small></pre>\n";

    # One kind of variable cannot be changed through these HTML forms.
    # $ok == -1 => automatically maintained variable

    if (ref ($val) eq 'ARRAY') {
      # Process as an array
      if ($ok > 0) {
        print <<EOM;
<form method=POST action="$cgiurl">
<input type=hidden name=domain value="$mj->{'domain'}">
<input type=hidden name=list value="$request->{'list'}">
<input type=hidden name=extra value="$var">
<input type=hidden name=passw value="$passw">
<input type=hidden name=st value="$request->{'st'}">
<textarea cols=70 rows=8 name=hereargs>
EOM
      }

      for (@$val) {
        print Mj::Format::escape($_) if defined $_;
      }

      if ($ok > 0) {
        print <<EOM;
</textarea><br>
<input type=submit name=func value="configset">
<input type=submit name=func value="configdef">
</form>
EOM
      }
    }
    else {
      # Process as a simple variable
      $val = "" unless defined $val;
      $val = Mj::Format::escape($val);
      if ($ok > 0) {
        print <<EOM;
<form method=POST action="$cgiurl">
<input type=hidden name=domain value="$mj->{'domain'}">
<input type=hidden name=list value="$request->{'list'}">
<input type=hidden name=passw value="$passw">
<input type=hidden name=st value="$request->{'st'}">
<input type=hidden name=extra value="$var">
EOM
        $vardata = $Mj::Config::vars{$var};
        # enum flags 
        if ($vardata->{'type'} =~ /^(?:integer|word|pw|bool)$/) {
          print "<input size=16 name=hereargs value=\"$val\">\n";
        }
        elsif ($vardata->{'type'} eq 'enum') {
          @possible = sort @{$vardata->{'values'}};
          print "<select name=hereargs>\n";
          for (@possible) {
            if ($_ eq $val) {
              print "<option selected> $_\n";
            }
            else {
              print "<option> $_\n";
            }
          }
          print "</select>\n";
        }
        elsif ($vardata->{'type'} eq 'flags') {
          @possible = @{$vardata->{'values'}};
          print "<select multiple name=hereargs>\n";
          for (@possible) {
            if ($val =~ /$_/) {
              print "<option selected> $_\n";
            }
            else {
              print "<option> $_\n";
            }
          }
          print "</select><br>\n";
        }
        else {
          print "<input size=70 name=hereargs value=\"$val\"><br>\n";
        }


        print <<EOM;
<input type=submit name=func value="configset">
<input type=submit name=func value="configdef">
</form>
EOM
      }
      else {
        print $val . "<p>\n";
      }
    }
  }
  select STDOUT;
  1;
}

sub Mj::Format::help { 
  my ($mj, $out, $err, $type, $request, $result) = @_;
  my $log = new Log::In 29, $request->{'topic'};
  my ($chunk, $chunksize, $topic);
  my ($ok, $mess) = @$result;

  select $out;
  unless ($ok > 0) {
    print "Help $request->{'topic'} failed.\n$mess";
    return $ok;
  }

  $chunksize = $mj->global_config_get($request->{'user'}, $request->{'password'},
                                      "chunksize");
  return unless $chunksize;

  $request->{'command'} = "get_chunk";


  while (1) {
    ($ok, $chunk) = @{$mj->dispatch($request, $chunksize)};
    last unless defined $chunk;
    $chunk = Mj::Format::escape($chunk);
    $chunk =~ s/(\s{3}|&quot;)(help\s)(configset|admin|mj) (?=\w)/$1$2$3_/g;
    $chunk =~ s/(\s{3}|&quot;)(help\s)(\w+)/$1$2<a href="$cgiurl?domain=$domain&func=help&extra=$3">$3<\/a>/g;
    print $chunk;
  }

  $request->{'command'} = "get_done";
  $mj->dispatch($request);
  select STDOUT; 
}

sub Mj::Format::showtokens {
  my ($mj, $out, $err, $type, $request, $result) = @_;
  my $log = new Log::In 29, $request->{'list'};
  my ($count, $created, $data, $ok, $size, @time, $token, @tokens);
  select $out;
  print "<input type=hidden name=list value=$request->{'list'}>\n";

  ($ok, @tokens) = @$result;
  unless ($ok) {
    print "<p>Showtokens error:  $tokens[0]\n";
    return 0;
  }
  unless (@tokens) {
    print "<br>There are no pending requests for $request->{'list'}.\n";
    return 0;
  }
  $count = 0;
  print "<table>\n";

  print "<tr><td colspan=5>Requests for $request->{'list'}\n";
  while (@tokens) {
    ($token, $data) = splice @tokens, 0, 2;
    print "<tr>\n";
    print "<td><input type=checkbox name=extra value=\"$token\">$token\n";
    print "<td>$data->{'list'}\n" if ($request->{'list'} eq 'ALL'); 
    if ($data->{'type'} eq 'consult') {
      print "<td>O\n";
    }
    else {
      print "<td>S\n";
    }
    $size = '';
    if ($data->{'command'} eq 'post' and $data->{'size'}) {
      $size = sprintf "(%2d&nbsp;kB)", ($data->{'size'} + 512) / 1024;
    }
    print "<td>$data->{'command'}&nbsp;$size\n";
    @time = localtime($data->{'time'});
    $created = sprintf "%.2d-%.2d&nbsp;%.2d:%.2d", 
      $time[4]+1, $time[3], $time[2], $time[1];
    print "<td>$created\n";
    print "<td>" . Mj::Format::escape($data->{'user'}) . "\n"; 
    $count++;
  }
  print "</table>\n";
  select STDOUT;
  $count;
} 

sub Mj::Format::tokeninfo {
  my ($mj, $out, $err, $type, $request, $result) = @_;
  my $log = new Log::In 29, $request->{'token'};
  my ($body, $chunk, $chunksize, $cmd, $expire);
  my (@reasons, $showspool, $time, $tmp, $user);
  my ($ok, $data, $sess) = @$result;
  select $out;

  unless ($ok > 0) {
    print "<p>Tokeninfo error: $data\n";
    return $ok;
  }
  
  $time   = localtime($data->{'time'});
  $expire = localtime($data->{'expire'});
  $user   = Mj::Format::escape($data->{'user'});
  $cmd    = Mj::Format::escape($data->{'cmdline'});

  print <<EOM;
<table>
<tr><td>Token  <td>$request->{'token'}
<tr><td>Created<td>$time
<tr><td>By     <td>$user
<tr><td>Type   <td>$data->{'type'}
<tr><td>Command<td>$cmd
<tr><td>Expires<td>$expire
EOM

  if ($data->{'arg2'}) {
    @reasons = split "\002", $data->{'arg2'};
    for (@reasons) {
      printf "<tr><td>Reason<td>%s\n", Mj::Format::escape($_);
    }
  }

  print "</table>\n";

  print <<EOM;
<form method=POST action="$cgiurl">
<input type=submit name=func value=accept>
<input type=submit name=func value=accept-archive>
<input type=submit name=func value=reject>
<input type=hidden name=domain value="$domain">
<input type=hidden name=extra value="$extra">
<input type=hidden name=list value=$request->{'list'}>
<input type=hidden name=passw value=$passw>
<input type=hidden name=st value=$request->{'st'}>
EOM

  if (exists $request->{'mlist'} and (ref $request->{'mlist'} eq 'ARRAY')) {
    for (@{$request->{'mlist'}}) {
      print "<input type=hidden name=mlist value=$_>\n"
        unless ($list eq $_);
    }
  }

  if ($sess) {
    $request->{'command'} = "get_chunk";
    $body = $showspool = 0;
    $chunksize = $tmp =
      $mj->global_config_get($request->{'user'}, $passw,
                             "chunksize");
    if ($request->{'mode'} eq 'full' and $data->{'command'} eq 'post') {
      $chunksize = 1;
      $showspool = 1;
    }
    print "<pre><small>\n";
    while (1) {
      ($ok, $chunk) = @{$mj->dispatch($request, $chunksize)};
      last unless defined $chunk;
      if ($showspool and !$body and $chunk =~ /^\r?\n/) {
        $body = 1;
        $chunksize = $tmp;
        print "</small>\n";
      }
      print Mj::Format::escape($chunk);
    }
    print "</small>" unless $showspool;
    print "</pre>\n";

    $request->{'command'} = "get_done";
    $mj->dispatch($request);

    if ($data->{'command'} eq 'post') {
      print <<EOM;
<input type=submit name=func value=accept>
<input type=submit name=func value=accept-archive>
<input type=submit name=func value=reject>
EOM
    }

  }

  print "</form>\n";
  select STDOUT;
} 

sub Mj::Format::who {
  my ($mj, $out, $err, $type, $request, $result) = @_;
  my $log = new Log::In 29, $request->{'list'};
  my ($arg, $chunksize, $count, $fullclass, $i, $lastchange);
  my (@lines, $numbered, $remove, @time, $user);

  if ($request->{'auxlist'}) {
    $remove = "auxremove";
  }
  elsif ($request->{'list'} eq 'GLOBAL') { 
    $remove = "unregister"; 
  }
  else {
    $remove = "unsubscribe";
  }
  select $out;

  my ($ok, $regexp, $tmpl) = @$result;
  if ($ok <= 0) {
    print "<p>Could not access $request->{'list'}:\n";
    return $ok;
  }
  print <<EOM;
<form method=POST action="$cgiurl">
<input type=submit name=func value="$remove">
<input type=hidden name=domain value="$domain">
<input type=hidden name=list value="$request->{'list'}">
<input type=hidden name=passw value="$passw">
<input type=hidden name=st value="$st">
<br>To remove addresses, choose one or more 
addresses from the list below, then press the <b>$remove</b> button.
<table>
EOM

  # We know we succeeded
  $count = 0;
  $chunksize = $mj->global_config_get($request->{'user'}, $passw, 
                                      "chunksize");
  return unless $chunksize;  
  $request->{'command'} = "who_chunk";
  
  while (1) {
    ($ok, @lines) = @{$mj->dispatch($request, $chunksize)};
    
    last unless $ok > 0;
    print "<tr><td cols=4>No matching addresses were found.\n"
      unless (@lines);
    for $i (@lines) {
      next unless (ref ($i) eq 'HASH');
      if ($request->{'list'} ne 'GLOBAL') {
        $fullclass = $i->{'class'};
        $fullclass .= "-" . $i->{'classarg'} if ($i->{'classarg'});
        $fullclass .= "-" . $i->{'classarg2'} if ($i->{'classarg2'});
      }
      else {
        $i->{'lists'} =~ s/\002/ /g;
      }
      $user = Mj::Format::escape($i->{'fulladdr'});
      @time = localtime($i->{'changetime'});
      $lastchange = sprintf "%4d-%.2d-%.2d", $time[5]+1900, $time[4]+1, $time[3];

      $count++;
      $arg = $i->{'stripaddr'};
      $arg = "$request->{'auxlist'} $arg" if ($request->{'auxlist'});
      print "<tr><td><input type=checkbox name=extra value=\"$arg\">$user\n";
      print "<td>$lastchange\n";

      if ($request->{'list'} eq 'GLOBAL') {
        print "<td>$i->{'lists'}\n";
      }
      else {
        print "<td>$i->{'flags'}<td>$fullclass\n";
      }
        
      if ($request->{'mode'} =~ /bounces/ && exists $i->{'bouncestats'}) {
        print "<tr><td cols=4>Diagnostic of last bounce: $i->{'diagnostic'}\n"
          if $i->{'diagnostic'};
        print "<tr><td cols=4>Bounces in the past week: $i->{'bouncestats'}->{'week'}\n"
          if $i->{'bouncestats'}->{'week'};
        print "<tr><td cols=4>Bounces in the past month: $i->{'bouncestats'}->{'month'}\n"
          if $i->{'bouncestats'}->{'month'};
        $numbered = join " ", sort {$a <=> $b} keys %{$i->{'bouncedata'}{'M'}};
        print "<tr><td cols=4>Message numbers: $numbered\n"
          if $numbered;
       
      }
    }
  }
  $request->{'command'} = "who_done";
  $mj->dispatch($request);

  print "</table>\n";
  if (exists $request->{'mlist'} and (ref $request->{'mlist'} eq 'ARRAY')) {
    for (@{$request->{'mlist'}}) {
      print "<input type=hidden name=mlist value=$_>\n"
        unless ($request->{'list'} eq $_);
    }
  }
  print "<input type=submit name=func value=$remove></form>\n";
  select STDOUT;
}

sub usage {
  my ($mj, $list, $cgiurl, $file) = @_;
  my $subs = {
              'CGIURL'   => $cgiurl,
              'DOMAIN'   => $mj->{'domain'},
              'LIST'     => $list,
              'MJ'       => $mj->global_config_get(undef, undef, 'whoami'),
              'MJOWNER'  => $mj->global_config_get(undef, undef, 'whoami_owner'),
              'SITE'     => $mj->global_config_get(undef, undef, 'site_name'),
          };
  my ($helpfile, undef) = $mj->_list_file_get('GLOBAL', 'wwwadm_help', $subs);
  &format_print($file);
  &format_print($helpfile);
  unlink $file;
  unlink $helpfile;
  exit 0;
}

sub surrender {
  my ($mess, $sess, $addr, $file) = @_;

  if ($file) {
    &format_print($file);
    unlink $file;
  }
  else {
    print <<EOM;
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
"http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head>
<title>Majordomo 2: Error</title>
</head>
<body>
EOM
  }

  print <<EOM;
<h2>Error: $mess</h2>
<pre>
$sess
</pre>
EOM

  print "Please contact <a href=\"mailto:$addr\">$addr</a>\n" .
        " if you wish to report this error.\n"  if $addr;

  print "</body></html>\n";
  exit 0;
}

=head1 COPYRIGHT

Copyright (c) 2000 Jason Tibbitts for The Majordomo Development
Group.  All rights reserved.

This program is free software; you can redistribute it and/or modify it
under the terms of the license detailed in the LICENSE file of the
Majordomo2 distribution.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the Majordomo2 LICENSE file for more
detailed information.

=cut

#^L
### Local Variables: ***
### cperl-indent-level:2 ***
### End: ***


