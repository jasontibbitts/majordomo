#!/usr/local/bin/perl-latest -wT
BEGIN {
  $::LIBDIR = 'unset';
  $::LISTDIR= 'unset';
  $::TMPDIR = 'unset';
  $::LOCKDIR= "blah";
  $::UMASK  = "007";
  $SIG{__WARN__} = sub {print STDERR "--== $_[0]"};

  # Redirect standard error output.
  if (! -t STDERR) {
    open (STDERR, ">>$::TMPDIR/mj_wwwadm.debug");
  }
}

=head1 NAME

mj_wwwadm - demonstration of majordomo administration via the WWW.

=head1 SYNOPSIS

 The command "configshow GLOBAL wwwadm_url" will display the URL.

=head1 DESCRIPTION

When utilizing majordomo with a CGI script, there are
several basic steps that must be taken, including initializing
majordomo variables,  creating a log (STDERR by default), 
initializing a CGI object, and starting a majordomo session
with connect().

=cut
use lib "$::LIBDIR";
use strict;
use CGI;
use Majordomo;
use Mj::Addr;
use Mj::CommandProps qw(:command :function);
use Mj::Format;
use Mj::Log;
use Mj::Parser;

my (%commands, %seen, @domains, @extra, @hereargs, @lists, @mlists, 
    @settings, @values, $addr, $cgi, $cgidata, $cgiurl, $domain, 
    $falseuser, $fh, $func, $i, $j, $line, $list, 
    $mess, $mode, $mj, $ofunc, $ok, $passw, $pathinfo, $req, $request, 
    $result, $sess, $str, $subs, $tmp, $token, $user);

#----- Which commands are supported ?  -----#
# First  value:  Is a password required?
# Second value:  Is a list required?
# Third value:  Should the result be preformatted?
# Fourth value:  Page to display after the result.
%commands = (   
                'accept'        => [1, 0, 1, 'showtokens'],
                'archive'       => [1, 1, 0, 'command'],
                'configdef'     => [1, 1, 1, 'configshow'],
                'configset'     => [1, 1, 1, 'configshow'],
                'configshow'    => [1, 1, 0, 'configshow'],
                'digest'        => [1, 1, 1, 'command'],
                'faq'           => [1, 1, 1, 'lists'],
                'get'           => [1, 1, 1, 'lists'],
                'help'          => [0, 0, 1, 'help'],
                'index'         => [1, 1, 1, 'lists'],
                'info'          => [1, 1, 1, 'lists'],
                'intro'         => [1, 1, 1, 'lists'],
                'lists'         => [1, 0, 0, 'lists'],
                'reject'        => [1, 0, 1, 'showtokens'],
                'report'        => [1, 1, 1, 'command'],
                'sessioninfo'   => [1, 0, 1, 'showtokens'],
                'set'           => [1, 1, 1, 'who'],
                'showtokens'    => [1, 1, 0, 'showtokens'],
                'subscribe'     => [1, 1, 1, 'who'],
                'tokeninfo'     => [1, 0, 0, 'showtokens'],
                'unregister'    => [1, 1, 1, 'who'],
                'unsubscribe'   => [1, 1, 1, 'who'],
                'welcome'       => [1, 1, 0, 'welcome'],
                'which'         => [1, 1, 1, 'who'],
                'who'           => [1, 1, 0, 'who'],
            );

#----- Initialize the Log -----#
&initialize_log;

#----- Initialize the CGI object -----#
$cgi = new CGI;

$tmp = '+50s';
print $cgi->header(-expires => $tmp);

#----- Multiple-list specification (used for showtokens) -----#
$pathinfo = $domain = '';
if (exists $ENV{'PATH_INFO'}) {
  $pathinfo = $ENV{'PATH_INFO'};
  while ($pathinfo =~ s#/domain=([a-zA-Z0-9.-]+)##) {
    $domain = $1;
  }

  $pathinfo =~ s#^/+##;
  $pathinfo =~ s#/+$##;
  if ($pathinfo =~ m#([\w/.-]+)#) {
    $pathinfo = $1;
  }
  else {
    $pathinfo = '';
  }
  @mlists = split '/', $pathinfo;
  if (@mlists) {
    for $i (@mlists) {
      unless (Majordomo::legal_list_name($i)) {
        &surrender(qq("$i" is an invalid list name.));
      }
    }
  }
}

unless ($domain) {
  $domain = $cgi->param('domain') || '';
}

# Clean up the URL by which this program was invoked.
$cgiurl = $cgi->script_name;
if ($domain) {
  $cgiurl .= "/domain=$domain";
}
if ($pathinfo) {
  $cgiurl .= "/$pathinfo";
}
$cgiurl = Mj::Format::uescape($cgiurl);

unless ($domain) {
  @domains = Majordomo::domains($::LISTDIR);
  ($domain) = grep { $_ eq $ENV{'HTTP_HOST'} } @domains;
  $domain = $domains[0] unless $domain;
}

# Untaint the domain name.
if ($domain =~ /([a-zA-Z0-9\.\-]+)/) {
  $domain = $1;
}
else {
  &surrender(qq("$domain" is an invalid domain.));
}

#----- Make the Majordomo object -----#
$mj = new Majordomo $::LISTDIR, $domain;
&surrender($mj) unless (ref $mj);

#----- Generate the session information. -----#
for my $i ('HTTP_HOST', 'REMOTE_ADDR','REMOTE_PORT', 'PATH_INFO') {
  $sess .= "$i = $ENV{$i}\n" if defined $ENV{$i};
}
$sess .= scalar(localtime(time)) . "\n";

#----- Determine the address of the user. -----#
$falseuser = "y$ENV{'REMOTE_ADDR'}\@example.com";
$user      = $cgi->param('user') || $falseuser;

$ofunc   = $cgi->param('func') || 'welcome';
@lists   = $cgi->param('list');
if ((! @lists) and @mlists) {
  @lists = @mlists;
}
$lists[0] ||= '';

#----- Initialize the variable substitutions -----#
$passw   = $cgi->param('passw') || '';
if ($passw) {
  $passw =~ /(.+)/; $passw = $1;
}

$cgidata = sprintf 'user=%s&list=%s', $user, $lists[0];
$cgidata = Mj::Format::uescape($cgidata);

$subs = { $mj->standard_subs($lists[0]),
          'CGIDATA'   => $cgidata,
          'CGIURL'    => $cgiurl,
          'COMMAND'   => $ofunc,
          'PASSWORD'  => '',
          'USER'      => $user,
        };


#----- Determine what service was requested -----#
# Extract "mode" from command name
if ($ofunc =~ /([^\s=-]+)[=-](.*)/) {
  $func = $1;
  $mode = $2;
}
else { 
  $ofunc =~ /(.*)/; $ofunc = $1;
  $func = $ofunc;
  $mode = '';
}

#----- Connect to the server -----#
($ok, $mess) = $mj->connect('wwwadm', $sess, $user, $passw);
unless ($ok) {
  &surrender($mess);
} 

#----- Remove the temporary password if the admin is signing out. -----#
if ($ofunc eq 'logout') {
  $mj->del_latchkey($passw) if ($mj->t_recognize($passw));
  $subs->{'PASSWORD'} = '';
  $subs->{'COMMAND'} = 'welcome';
}
else {
  $passw = $mj->gen_latchkey($passw) 
    if ($passw and !$mj->t_recognize($passw));
  $subs->{'PASSWORD'} = $passw;
  $cgidata = sprintf 'user=%s&passw=%s&list=%s', $user, $passw, $lists[0];
  $cgidata = Mj::Format::uescape($cgidata);
  $subs->{'CGIDATA'} = $cgidata;
}

#----- Print the generic page header -----#
$tmp = $mj->format_get_string('wwwadm', 'head');
$str = $mj->substitute_vars_format($tmp, $subs);
print STDOUT "$str\n";

if ($ofunc eq 'logout') {
  &usage($mj, $subs, 'You have successfully signed out.');
}
unless (length $lists[0]) {
  &login($mj, $subs, '');
}

($i) = $mj->valid_list($lists[0], 1, 1);
unless (defined $i) {
  &login($mj, $subs, "Invalid list: \"$lists[0]\".");
}
unless ($passw) {
  &login($mj, $subs, '');
}
$addr = new Mj::Addr($user);
unless ($mj->validate_passwd($addr, $passw, $i, 'ALL')) {
  &login($mj, $subs, 'Invalid password.');
}

if ($ofunc eq 'login') {
  &login($mj, $subs, '');
}
elsif ($ofunc eq 'welcome') {
  &usage($mj, $subs, '');
}
elsif ($ofunc eq 'command') {
  &command($mj, $subs, '');
}

# Make sure the command is valid
unless (exists $commands{$func}) {
  &usage($mj, $subs, "$func is an unsupported command.");
}

# The archive-get and archive-index commands must use immediate mode,
# to display the results instead of mailing them.
if ($func eq 'archive' or $func eq 'get') {
  $mode .= $mode? "-immediate" : "immediate";
}
elsif ($func eq 'who') {
  $mode .= $mode? "-enhanced" : "enhanced";
}


#----- Password check -----#
if (! $passw) {
  &usage($mj, $subs, "A password is required to use the $func command.")
    if ($commands{$func}->[0]);
}

#----- List check -----#
if ($commands{$func}->[2] and ! scalar @lists) {
  &usage($mj, $subs, "A mailing list must be provided to use the \"$func\" command.");
}

no strict 'refs';

$request = {
    'cgiurl'    => $cgiurl,
    'command'   => $func,
    'list'      => $lists[0],
    'mode'      => $mode,
    'password'  => $passw, 
    'user'      => $user,
};

# Deal with result sets
if ($func eq 'who') {
  $request->{'chunksize'} = $cgi->param('chunksize') || 0;
  $request->{'start'} = $cgi->param('start') || 1;
}

if (function_prop($func, 'iter')) {
  $request->{'command'} .= '_start';
}


#----- Process command arguments -----#
# Normally, the "extra" variable is used to hold command arguments.
# However, there are some cases in which this approach is inadequate.
#
# The first is with the configset command, in the case that more
# than one setting is changed at once.
#
# The second exception is for the subscribe-set command, which
# must have both addresses and settings available.
#
# The third exception is for the accept and reject commands,
# which must allow an explanation to be sent back to the person
# whom the command affects.
#
# The fourth exception is for the set command, which must include
# separate settings for each address affected.
#
# The fifth exception is for the report command, which must include
# separate action and time span values.
#
# The sixth exception is for the configshow command, which allows
# an array of variables to be specified.
#
# The seventh exception is for the who command, which must include
# a pattern.
#
# In each of these cases, the basic command form requires that the
# "extra" variable still be handled if it was used.
@extra = $cgi->param('extra');
if (@extra and $func ne 'showtokens') {
  for $req (@extra) {
    Mj::Parser::parse_args($request, $req, '');
    # Deal with accept/reject reasons.
    if ($func =~ /accept|reject/) {
      $request->{'xplanation'} ||= $cgi->param('xplanation');
    }
    if ($func eq 'configset' and not $cgi->param('command')) {
      @values = split "\r?\n", $cgi->param($req);
      $request->{'value'} = [@values];
    }  
    $result = $mj->dispatch($request); 
    &usage($mj, $subs, "Unable to obtain result from Majordomo.") unless $result;
    print "<pre>\n" if ($commands{$func}->[2]);
    &{"Mj::Format::$func"}($mj, \*STDOUT, \*STDOUT, 'wwwadm', $request, $result);
    print "</pre>\n" if ($commands{$func}->[2]);;
    if (function_prop($func, 'iter')) {
      $request->{'command'} =~ s/done/start/;
    }
  }
}
elsif ($func eq 'set') {
  @extra = $cgi->param('victims');
  for $addr (@extra) {
    @values = $cgi->param($addr);
    $request->{'setting'} = join ",", @values;
    for $j (qw(ackdeny ackpost ackreject ackstall eliminatecc hideaddress
               hideall postblock prefix replyto selfcopy rewritefrom)) {
      unless (grep { $_ eq $j } @values) {
        $request->{'setting'} .= ",no$j";
      }
    }
    $request->{'victims'} = [ $addr ];
    $result = $mj->dispatch($request); 
    &usage($mj, $subs, "Unable to obtain result from Majordomo.") unless $result;
    print "<pre>\n" if ($commands{$func}->[2]);
    &{"Mj::Format::$func"}($mj, \*STDOUT, \*STDOUT, 'wwwadm', $request, $result);
    print "</pre>\n" if ($commands{$func}->[2]);;
  }
}
# The remaining exceptions, other than showtokens, require only one dispatch call.
elsif ($func ne 'showtokens') {
  if ($func eq 'accept' or $func eq 'reject') {
    @extra = $cgi->param('tokens');
    $request->{'tokens'} = [ @extra ];
    $request->{'xplanation'} = join "\n", $cgi->param('xplanation');
  }
  elsif ($func eq 'subscribe' or $func eq 'unsubscribe') {
    @extra = $cgi->param('victims');
    if (scalar @extra == 1) {
      @extra = split "\r?\n", $extra[0];
    }
    $request->{'victims'} = [ @extra ];
    if ($func eq 'subscribe' and $mode =~ /set/) {
      @extra = $cgi->param('setting');
      $request->{'setting'} = join ',', @extra;
      for $j (qw(ackdeny ackpost ackreject ackstall eliminatecc hideaddress
                 hideall postblock prefix replyto selfcopy rewritefrom)) {
        unless (grep { $_ eq $j } @extra) {
          $request->{'setting'} .= ",no$j";
        }
      }
    }
  }
  elsif ($func eq 'report') { 
    $request->{'action'} = join ',', $cgi->param('action');
    $request->{'date'} = $cgi->param('date');
  }
  elsif ($func eq 'configshow') {
    $request->{'groups'} = join ',', $cgi->param('groups');
  }
  elsif ($func eq 'who') {
    $request->{'regexp'} = $cgi->param('pattern');
  }
  $result = $mj->dispatch($request); 
  &usage($mj, $subs, "Unable to obtain result from Majordomo.") unless $result;
  print "<pre>\n" if ($commands{$func}->[2]);
  &{"Mj::Format::$func"}($mj, \*STDOUT, \*STDOUT, 'wwwadm', $request, $result);
  print "</pre>\n" if ($commands{$func}->[2]);;
}

#----- Display supplementary information -----#
# There are five supplementary screens which this script displays. 
#   command    - Display a command menu
#   configshow - allow easy access to collections of settings
#   lists      - Show details about a list, or a collection of lists.
#   showtokens - Display a list of pending requests
#   who        - Search the subscriber list or (un)subscribe addresses

$tmp = $cgi->param('command') || '';
if (($tmp eq 'on' and $func ne 'showtokens')
    or $commands{$func}->[3] eq 'command') {
  &command($mj, $subs, '');
}
elsif ($commands{$func}->[3] eq 'showtokens') {
  # A separate head and foot are needed because this interface
  # can display tokens for any number of mailing lists.
  $tmp = $mj->format_get_string('wwwadm', 'showtokens_head');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print "$str\n";

  Mj::Parser::parse_args($request, $extra[0], '')
    if ($func eq 'showtokens' and $extra[0]);
  $i = 0;
  $request->{'command'} = 'showtokens';
  $request->{'mode'} = 'delay';
  my (%seen);
  for $list (@lists, @mlists) {
    next if (exists $seen{$list});
    $request->{'list'} = $list;
    $result = $mj->dispatch($request);
    # Increase the token count if any tokens were found.
    if ($result->[0]) {
      $i += int($#$result / 2);
    }
    &{"Mj::Format::showtokens"}($mj, \*STDOUT, \*STDOUT, 'wwwadm', 
                                      $request, $result);
    $seen{lc $list}++;
  }

  $subs->{'COUNT'} = $i;
  $tmp = $mj->format_get_string('wwwadm', 'showtokens_foot');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print "$str\n";

  if ($cgi->param('command') eq 'on' and $func eq 'showtokens') {
    &command($mj, $subs, '');
  }
}
elsif ($commands{$func}->[3] ne $func) {
  if ($commands{$func}->[3] eq 'configshow') {
    $func = $request->{'command'} = 'configshow';
    $request->{'mode'} = 'categories';
    $request->{'list'} = $lists[0];
  }
  elsif ($commands{$func}->[3] eq 'lists') {
    $func = $request->{'command'} = 'lists';
    $request->{'mode'} = 'long';
    $request->{'list'} = 'GLOBAL';
    $request->{'regexp'} = $lists[0];
  }
  elsif ($commands{$func}->[3] eq 'who') {
    $func = 'who';
    $request->{'command'} = 'who_start';
    $request->{'mode'} = 'enhanced';
    $request->{'list'} = $lists[0];
    $request->{'chunksize'} = $cgi->param('chunksize') || 20;
    $request->{'start'} = $cgi->param('start') || 1;
    $request->{'regexp'} = $cgi->param('pattern');
    $request->{'victims'} = '';
  }
  $result = $mj->dispatch($request); 
  &usage($mj, $subs, "Unable to obtain result from Majordomo.") unless $result;
  &{"Mj::Format::$func"}($mj, \*STDOUT, \*STDOUT, 'wwwadm', $request, $result);
}

#----- Print the Footer -----#
$tmp = $mj->format_get_string('wwwadm', 'foot');
$str = $mj->substitute_vars_format($tmp, $subs);
print STDOUT "$str\n";

#----- Subroutines -----#

sub command {
  my ($mj, $subs, $message) = @_;
  my ($str, $tmp);

  $subs->{'ERROR'} = $message;
  $::log->message(50, "info", $message) if $message;

  $tmp = $mj->format_get_string('wwwadm', 'command');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";

  $tmp = $mj->format_get_string('wwwadm', 'foot');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";
  
  exit 1;
}

sub initialize_log {
  $ENV{'PATH'} = "/bin:/usr/bin:/usr/ucb";

  umask oct($::UMASK);

  # Change the log level to a higher number (600) for complete debugging.
  $::log = new Mj::Log;
  $::log->add
    (
     method      => 'handle',
     id          => 'wwwadm',
     handle      => \*STDERR,
     level       => 50,
     subsystem   => 'mail',
     log_entries => 1,
     log_exits   => 1,
     log_args    => 1,
    );

  $::log->in(20, undef, "info", 
    "Majordomo WWW for List Owners - " . scalar(localtime) .
     " from $ENV{'REMOTE_ADDR'}");

  $::log->startup_time();
}

sub login {
  my $mj = shift; 
  my $subs = shift;
  my $message = shift || '';
  my ($str, $tmp);

  $subs->{'ERROR'} = $message;
  $subs->{'COMMAND'} = "welcome"
   if ($subs->{'COMMAND'} eq "login");

  if ($message) {
    $str = $message . "  Request: $subs->{'COMMAND'}  List: $subs->{'LIST'}";
    $::log->message(50, "info", $message);
    $mj->inform('GLOBAL', 'connect', $subs->{'USER'}, 
                $subs->{'USER'}, "(wwwadm request from $ENV{'REMOTE_ADDR'})",
                'wwwadm', 0, 0, 0, $str, $::log->elapsed);
  }

  $tmp = $mj->format_get_string('wwwadm', 'login');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";

  $tmp = $mj->format_get_string('wwwadm', 'foot');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";
  
  exit 1;
}

sub usage {
  my ($mj, $subs, $message) = @_;
  my ($str, $tmp);

  $subs->{'ERROR'} = $message;
  $::log->message(50, "info", $message) if $message;

  $tmp = $mj->format_get_string('wwwadm', 'welcome');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";

  $tmp = $mj->format_get_string('wwwadm', 'foot');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";
  
  exit 1;
}

sub surrender {
  my ($message) = shift;
  $::log->message(50, "info", $message) if $message;
  my ($url) = $cgi->script_name;

  print <<EOM;
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
"http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head>
<title>Majordomo 2 WWW for List Owners: Error</title>
</head>
<body>
<h2 align=center>Majordomo Error</h2>
$message
<form method=POST action="$url">
  <input type=hidden name=func value="login">
  Enter the domain name into the box, then press the <b>Sign In</b> button.<br>
  <input name=domain size=45>
  <input type=submit value="Sign In">
</form>
EOM

  if (defined $subs and exists $subs->{'MJOWNER'}) {
    print <<EOM;
Please contact 
<a href="mailto:$subs->{'MJOWNER'}">$subs->{'MJOWNER'}</a>
 for assistance.
EOM
  }

print "</body></html>\n";

  exit 0;
}


=head1 COPYRIGHT

Copyright (c) 2000 Jason Tibbitts for The Majordomo Development
Group.  All rights reserved.

This program is free software; you can redistribute it and/or modify it
under the terms of the license detailed in the LICENSE file of the
Majordomo2 distribution.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the Majordomo2 LICENSE file for more
detailed information.

=cut

#^L
### Local Variables: ***
### cperl-indent-level:2 ***
### End: ***


