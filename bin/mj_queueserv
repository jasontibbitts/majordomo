#!/usr/bin/perl -wT
BEGIN {
  $::BINDIR = "/path/to/bin";
#  $::LIBDIR = "/path/to/lib";
#  $::LISTDIR= "/path/to/lists";
#  $::DEFDOM = "some.dom.ain";
#  $::LOCKDIR= "blah";
  $::TMPDIR = "/tmp/mj";
#  $::WTMPDIR= "/tmp";
#  $::UMASK  = "007";
#  $Exporter::Verbose = 1;
#  $AutoLoader::Verbose = 1;
#  $AutoLoader::Notruncate = 1;
  $::UID    = "baduid";
  $::GID    = "badgid";
  $::TIMEOUT = 30;
  $::CONCURRENCY = 5;
  $SIG{__WARN__} = sub {print STDERR "--== $_[0]"};

  # Redirect standard error output.
  if (! -t STDERR) {
    open (STDERR, ">>$::TMPDIR/mj_queueserv.debug");
  }

  # Croak if install was botched
  die("Not running as UID $::UID") unless $> == $::UID;
  die("Not running as GID $::GID") unless $) == $::GID;
}

use Socket;
use POSIX;
use IO::Handle;
use strict;
$|=1;
$ENV{PATH} = '';

sub logmsg { print STDERR "[$$].Queueserv: @_\n"; }
sub out { logmsg "Out: $_[1]"; syswrite($_[0], $_[1], length($_[1])) }
sub in  { logmsg "In..."; sysread($_[0], $_, 1024); logmsg "In: $_"; $_ };

my(@child, @parent, $ein, $eout, $i, $in, $line, $nfound, $out, $pid,
   $ping, $rin, $rout, $use_child, $win, $wout);

my $sock = "$::TMPDIR/mj_queueserv.sock";
my $uaddr = sockaddr_un($sock);
my $proto = getprotobyname('tcp');
my $debug = '';
$debug = " -v $ARGV[0]" if defined $ARGV[0];
$debug =~ /(.*)/; $debug = $1; # Only mj_enqueue calls us, so $ARGV[0] is safe.

# Become a daemon
$pid = fork;
exit if $pid;
die "Couldn't fork: $!" unless defined($pid);
POSIX::setsid() or die "Can't start a new session: $!";

$SIG{CHLD} = 'IGNORE';
$SIG{PIPE} = 'IGNORE';

logmsg("Majordomo Queue Server - ".scalar(localtime));

socket(Server,PF_UNIX,SOCK_STREAM,0)        || die "socket: $!";
unlink($sock);
bind  (Server, $uaddr)                      || die "bind: $!";
listen(Server,SOMAXCONN)                    || die "listen: $!";

logmsg "Server started on $sock";

# Loop until we exit explicitly
MAIN:
while (1) {

  # Select on the Socket, time out after a while
  $rin = $win = $ein = ''; vec($rin,fileno(Server),1) = 1; $ein = $rin | $win;
  unless (select($rout=$rin, $wout=$win, $eout=$ein,
		 $::TIMEOUT*$::CONCURRENCY)
	 )
    {
      logmsg "Timed out";
      last;
    }

  # Got a connection, accept it
  accept(Client,Server);
  logmsg "Got connection";

  $line = in(*Client);
  if ($line =~ /quit/i) {
    logmsg "Asked to quit; shutting down";
    last;
  }

  # Compress the child list
  @child = grep { defined } @child;

  # Find a child that can read or start a new one
  undef $use_child;
 PICK:
  for ($i = 0; $i < @child; $i++) {
    # Ping a child; if we fail while writing, it's dead.  If the response
    # doesn't come back soon, it's busy.  Note that we have to exclude
    # buffered ping responses here, so we send along the time.
    #logmsg "Checking $i";
    $ping = 'Ping ' . time;
    unless (out($child[$i], $ping)) {
      logmsg "$i is dead";
      $child[$i]->close;
      undef $child[$i];
      next PICK;
    }

    # We want to get a response, but there may be buffered responses to
    # previous pings that the client didn't answer immediately.
  PING:
    while(1) {
      $rin = $win = $ein = ''; vec($rin,fileno($child[$i]),1) = 1; $ein = $rin | $win;
      $nfound = select($rout=$rin, $wout=$win, $eout=$ein, .25);
      if ($nfound && $rout) {
	$line = in($child[$i]);
	unless (defined($line) && (length($line))) {
	  logmsg "Weird; got an empty line from $i";
	  $child[$i]->close;
	  undef $child[$i];
	  next PICK;
	}

	# If the response has Exiting anywhere, the client is gone
	if ($line =~ /Exiting/) {
	  logmsg "$i has exited";
	  $child[$i]->close;
	  undef $child[$i];
	  next PICK;
	}

	# If we got the ping back, we're set
	elsif ($line =~ /$ping$/) {
	  logmsg "$i pinged successfully";
	  last PING;
	}
	else {
	  logmsg "$i had stale response";
	  next PING;
	}
      }
      else {
	logmsg "$i is busy";
	next PICK;
      }
    }
    logmsg "Using child $i";
    $use_child = $i;
    last PICK;
  }
  if (!defined($use_child) && @child < $::CONCURRENCY) {
    $i = scalar(@child);
    logmsg "Starting new runner $i";

    # Setup a pipe set for the child
    $child[$i]  = new IO::Handle; $child[$i]->autoflush(1);
    $parent[$i] = new IO::Handle; $parent[$i]->autoflush(1);
    socketpair($child[$i], $parent[$i], AF_UNIX, SOCK_STREAM, PF_UNSPEC) || die "Socketpair: $!";

    # Start a runner
    if (!($pid = fork)) {
      die "Cannot fork: $!" unless defined $pid;

      #logmsg "Starting runner";
      $child[$i]->close;
      close Client; # Otherwise the runner holds it open

      # Redirect stdin and out so the runner is simple
      $in = fileno($parent[$i]);
      $out= fileno($parent[$i]);
      open *STDIN , "<&$in";
      open *STDOUT, ">&$out";

      exec "$::BINDIR/mj_queuerun$debug";
      die "Couldn't exec $::BINDIR/mj_queuerun: $!";
    }
    else {
      # Parent...
      $parent[$i]->close;

      # Get back the greeting. XXX The timeout is arbitrary and should be
      # tuneable.
      $rin = $win = $ein = ''; vec($rin,fileno($child[$i]),1) = 1; $ein = $rin | $win;
      if(select($rout=$rin, $wout=$win, $eout=$ein, 10)) {
	$line = in($child[$i]);
	logmsg "Runner is awake, said $line";
	$use_child = $i;
      }
      else {
	# The child never said hello...
	logmsg "Runner did not respond.";
	out(*Client, "Problems starting queue runner; queueing");
	close Client;
	next;
      }
    }
  }
  if (!defined($use_child)) {
    out(*Client, "Excessive load; queueing");
    close Client;
    next;
  }

  # Tell the client to go.
  unless (out($child[$use_child], "Parent $$ sending")) {
    # It was alive just a second ago, but now it's dead.  So we just
    # pretend we have high load.
    out(*Client, "Excessive load; queueing");
    close Client;
    next;
  }

  # Get the response back from the client
  $line = in($child[$use_child]);
  
  # Hand it back to the client
  out(*Client, $line);
  close Client;
}

# Out of while() loop; time to die.
logmsg "Shutting down";
exit;
