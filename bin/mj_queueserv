#!/usr/bin/perl -wT
BEGIN {
  $::BINDIR = "/path/to/bin";
  $::TMPDIR = "/tmp/mj";
  $::UID    = "baduid";
  $::GID    = "badgid";
  $::TIMEOUT = 30;
  $::CONCURRENCY = 5;
  $::SIG_CHLD_IGNORE = 1;
  $SIG{__WARN__} = sub {print STDERR "--== $_[0]"};

  # Zmailer defines the input field separator.  Untaint it.
  delete $ENV{'IFS'};

  # Redirect standard error output.
  if (! -t STDERR) {
    open (STDERR, ">>$::TMPDIR/mj_queueserv.debug") or
      die "Can't redirect debug output to $::TMPDIR/mj_queueserv.debug: $!";
  }

  # Croak if install was botched
  die("Not running as UID $::UID") unless $> == $::UID;
  die("Not running as GID $::GID") unless $) == $::GID;
}

use Socket;
use POSIX;
use Symbol;
use strict;
$|=1;
$ENV{PATH} = '';

sub logmsg { print STDERR "[$$].Queueserv: @_\n"; }
sub out { logmsg "Out: $_[1]"; syswrite($_[0], $_[1], length($_[1])) }
sub in  { logmsg "In..."; sysread($_[0], $_, 1024); logmsg "In: $_"; $_ };

my(@child, @parent, $ein, $eout, $i, $in, $line, $nfound, $out, $pid,
   $ping, $rin, $rout, $use_child, $win, $wout);

my $sock = "$::TMPDIR/mj_queueserv.sock";
my $uaddr = sockaddr_un($sock);
my $proto = getprotobyname('tcp');
my $debug = '';
$debug = " -v $ARGV[0]" if defined $ARGV[0];
$debug =~ /(.*)/; $debug = $1; # Only mj_enqueue calls us, so $ARGV[0] is safe.

# Become a daemon
$pid = fork;
exit if $pid;
die "Couldn't fork: $!" unless defined($pid);
POSIX::setsid() or die "Can't start a new session: $!";

# Set up a bit of signal handling
$SIG{PIPE} = 'IGNORE';
if ($::SIG_CHLD_IGNORE) {
  $SIG{CHLD} = 'IGNORE';
}
else {
  $SIG{CHLD} = sub {wait};
}

logmsg("Majordomo Queue Server - ".scalar(localtime));

socket(Server,PF_UNIX,SOCK_STREAM,0)        or die "socket: $!";
unlink($sock);
bind  (Server, $uaddr)                      or die "bind: $!";
listen(Server,SOMAXCONN)                    or die "listen: $!";

logmsg "Server started on $sock";

# Loop until we exit explicitly
MAIN:
while (1) {

  # Select on the Socket, time out after a while
  $rin = $win = $ein = ''; vec($rin,fileno(Server),1) = 1; $ein = $rin | $win;
  $nfound = select($rout=$rin, $wout=$win, $eout=$ein,
		   $::TIMEOUT*$::CONCURRENCY);

  # select returns 0 on a timeout
  if ($nfound == 0) {
    logmsg "Timed out";
    last;
  }

  # select returns -1 if interrupted by a system call (like SIGCHLD)
  next if $nfound < 0;

  # Got a connection, accept it
  logmsg "Got connection";
  accept(Client,Server);
  logmsg "Accepted connection";

  $line = in(*Client);
  if ($line =~ /quit/i) {
    logmsg "Asked to quit; shutting down";
    last;
  }

  # Compress the child list
  @child = grep { defined } @child;

  # Find a child that can read or start a new one
  undef $use_child;
 PICK:
  for ($i = 0; $i < @child; $i++) {
    # Ping a child; if we fail while writing, it's dead.  If the response
    # doesn't come back soon, it's busy.  Note that we have to exclude
    # buffered ping responses here, so we send along the time.
    #logmsg "Checking $i";
    $ping = 'Ping ' . time;
    unless (out($child[$i], $ping)) {
      logmsg "$i is dead";
      close $child[$i];
      undef $child[$i];
      next PICK;
    }

    # We want to get a response, but there may be buffered responses to
    # previous pings that the client didn't answer immediately.
  PING:
    while(1) {
      $rin = $win = $ein = ''; vec($rin,fileno($child[$i]),1) = 1; $ein = $rin | $win;
      $nfound = select($rout=$rin, $wout=$win, $eout=$ein, .25);
      if ($nfound && $rout) {
	$line = in($child[$i]);
	unless (defined($line) && (length($line))) {
	  logmsg "Weird; got an empty line from $i";
	  close $child[$i];
	  undef $child[$i];
	  next PICK;
	}

	# If the response has Exiting anywhere, the client is gone
	if ($line =~ /Exiting/) {
	  logmsg "$i has exited";
	  close $child[$i];
	  undef $child[$i];
	  next PICK;
	}

	# If we got the ping back, we're set
	elsif ($line =~ /$ping$/) {
	  logmsg "$i pinged successfully";
	  last PING;
	}
	else {
	  logmsg "$i had stale response";
	  next PING;
	}
      }
      else {
	logmsg "$i is busy";
	next PICK;
      }
    }
    logmsg "Using child $i";
    $use_child = $i;
    last PICK;
  }
  if (!defined($use_child) && @child < $::CONCURRENCY) {
    $i = scalar(@child);
    logmsg "Starting new runner $i";

    # Setup a pipe set for the child
    $child[$i]  = gensym; 
    $parent[$i] = gensym; 
    socketpair($child[$i], $parent[$i], AF_UNIX, SOCK_STREAM, PF_UNSPEC) or die "Socketpair: $!";
    &af($child[$i]);
    &af($parent[$i]);

    # Start a runner
    if (!($pid = fork)) {
      die "Cannot fork: $!" unless defined $pid;

      #logmsg "Starting runner";
      close $child[$i];
      close Client; # Otherwise the runner holds it open

      # Redirect stdin and out so the runner is simple
      $in = fileno($parent[$i]);
      $out= fileno($parent[$i]);
      open *STDIN , "<&$in";
      open *STDOUT, ">&$out";

      exec "$::BINDIR/mj_queuerun$debug";
      die "Couldn't exec $::BINDIR/mj_queuerun: $!";
    }
    else {
      # Parent...
      close $parent[$i];

      # Get back the greeting. XXX The timeout is arbitrary and should be
      # tuneable.
      $rin = $win = $ein = ''; vec($rin,fileno($child[$i]),1) = 1; $ein = $rin | $win;
      if(select($rout=$rin, $wout=$win, $eout=$ein, 30)) {
	$line = in($child[$i]);
	logmsg "Runner is awake, said $line";
	$use_child = $i;
      }
      else {
	# The child never said hello...
	logmsg "Runner did not respond.";
	out(*Client, "Problems starting queue runner; queueing");
	close Client;
	next;
      }
    }
  }
  if (!defined($use_child)) {
    out(*Client, "Excessive load; queueing");
    close Client;
    next;
  }

  # Tell the client to go.
  unless (out($child[$use_child], "Parent $$ sending")) {
    # It was alive just a second ago, but now it's dead.  So we just
    # pretend we have high load.
    out(*Client, "Excessive load; queueing");
    close Client;
    next;
  }

  # Get the response back from the client
  $line = in($child[$use_child]);
  
  # Hand it back to the client
  out(*Client, $line);
  close Client;
}

# Out of while() loop; time to die.
logmsg "Shutting down";
exit;

sub af {
  my ($sock) = shift;
  my ($tmp);
  # Autoflush the socket
  $tmp = select;
  select $sock;
  $| = 1;  
  select $tmp;
}

=head1 NAME

mj_queueserv - Overseer of mj_queuerun processes.

=head1 SYNOPSIS

Started only from mj_enqueue; not to be run by hand.

=head1 DESCRIPTION

This is a small process that oversees a pool of mj_queuerun processes.  It
is intended to be started by mj_enqueue and only one should ever be active
at any time.

mj_queueserv immediately forks and disassociates itself from its parent
process so it can run as a daemon.  It opens a socket and awaits
connections; if it sits idle for a period of time or if instructed to (see
L<mj_shutdown>) it will exit (as will any existing mj_queuerun processes,
once they have finished their work).

=head1 COPYRIGHT

Copyright (c) 1999 Jason Tibbitts for The Majordomo Development
Group.  All rights reserved.

This program is free software; you can redistribute it and/or modify it
under the terms of the license detailed in the LICENSE file of the
Majordomo2 distribution.

his program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the Majordomo2 LICENSE file for more
detailed information.

=cut

#
### Local Variables: ***
### mode:cperl ***
### cperl-indent-level:2 ***
### End: ***
