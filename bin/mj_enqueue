#!/usr/bin/perl -wT
BEGIN {
  $::BINDIR = "/path/to/bin";
#  $::LIBDIR = "/path/to/lib";
  $::LISTDIR= "/path/to/lists";
  $::TMPDIR = "/tmp/mj";
#  $::WTMPDIR= "/tmp";
  $::UMASK  = "007";
  $::UID    = "baduid";
  $::GID    = "badgid";
#  $Exporter::Verbose = 1;
#  $AutoLoader::Verbose = 1;
#  $AutoLoader::Notruncate = 1;
  $SIG{__WARN__} = sub {print STDERR "--== $_[0]"};

  # Redirect standard error output.
  if (! -t STDERR) {
    open (STDERR, ">>$::TMPDIR/mj_enqueue.debug") or
      die "Can't redirect debug output to $::TMPDIR/mj_enqueue.debug: $!";
  }

  # Croak if install was botched
  die("Not running as UID $::UID") unless $> == $::UID;
  die("Not running as GID $::GID") unless $) == $::GID;

  # Hardcoded constants so we don't usve to use Fcntl
  $::LOCK_EX  = "blah";
  $::LOCK_NB  = "blah";
  $::O_WRONLY = "blah";
  $::O_CREAT  = "blah";
  $::O_EXCL   = "blah";
}

use Socket;
#use Fcntl qw(:flock :DEFAULT);
use Getopt::Std;
use strict;


sub logmsg { print STDERR "[$$].Enqueue: @_\n"; }
sub out { logmsg("Out: $_[1]"); syswrite($_[0], $_[1], length($_[1])) }
sub in  { logmsg("In..."); sysread($_[0], $_, 1024); logmsg("In: $_"); $_ };

my (%opts, $dom, $i, $line, $ok, $pid, $rendezvous, $q1, $q2, $q3,
    $qdir, $qfile, $qfunc, $abandoned);

umask oct($::UMASK);
$ENV{PATH} = '';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Parse command line args
# -c - specify command to be executed (arg)
# -d - specify domain to serve (arg)
# -l - specify list (arg)
# -m - run at main majordomo address; -l ignored.
# -o - run as owner answerer
# -P - specify domain priority
# -p - specify list priority
# -q - run as request answerer; -l _required_.
# -r - run as resend; -l _required_.
# -t - specify directory containing domains (arg)
# -v - specify debug verbosity (arg), default 50.
# -x - specify auxiliary list (arg)
# -M - run as moderator answerer
# -Q - figure out addresses from $ENV{DEFAULT} (for qmail) or use
#      $ENV{LOCAL} if $ENV{DEFAULT} does not exist
#      argument is $whoami for this domain
# -S - when done, exit 99 instead of 0 (for qmail)
# -T - for qmail versions prior to 1.03, trim this string from $ENV{LOCAL}.

getopts('c:d:l:mMop:P:qQ:rSt:T:v:x:', \%opts);

# Deal with -Q option
do_qmail() if $opts{'Q'};

$dom = $opts{'d'}; 
$dom =~ /([a-zA-Z0-9\-\.]+)/; $dom = $1;
die ("mj_enqueue:  No domain was specified.\n") unless $dom;

$opts{'p'} = 10 unless defined $opts{'p'};
$opts{'P'} = 10 unless defined $opts{'P'};
$opts{'v'} ||= 0;

# Choose the function; the queue name
if    ($opts{'m'}) { $qfunc = 'majordomo'}
elsif ($opts{'o'} or $opts{'M'}) { $qfunc = 'owner'    }
elsif ($opts{'q'} or $opts{'c'}) { $qfunc = 'request'  }
elsif ($opts{'r'} or $opts{'x'}) { $qfunc = 'list'     }

# Figure out the queue directory and make sure everything exists.
$qdir = "$::LISTDIR/QUEUE/$opts{'P'}/$dom/$opts{'p'}/$qfunc";
smkdir("$::LISTDIR",                                  0777);
smkdir("$::LISTDIR/QUEUE",                            0777);
smkdir("$::LISTDIR/QUEUE/$opts{'P'}",                 0777);
smkdir("$::LISTDIR/QUEUE/$opts{'P'}/$dom",            0777);
smkdir("$::LISTDIR/QUEUE/$opts{'P'}/$dom/$opts{'p'}", 0777);
smkdir("$qdir",                                      0777);

# Construct some strings
$q1 = chr(ord('A') + (localtime(time))[2]);
$q2 = 'AA';
if ($opts{'l'}) { $q3 = "-$opts{'l'}"}
else            { $q3 = '' }

# Append the command, auxiliary list, or ",M" (for -moderator)
# to the queue file name.
if    ($opts{'M'}) { $q3 .= ",M"}
elsif ($opts{'c'}) { $q3 .= ",$opts{'c'}"}
elsif ($opts{'x'}) { $q3 .= ",$opts{'x'}"}

# Loop through until we have a unique string.  If we loop until ZZ then
# this will still work but we should be careful about the length of things.
while (1) {
  $qfile = "$q1$q2-${$}${q3}";
  $ok = sysopen(OUT, "$qdir/$qfile", $::O_WRONLY|$::O_CREAT|$::O_EXCL, 0777);
  last if $ok;
  # XXX Hack?
  # die "Can't create queue file $qdir/$qfile: $!" unless $! =~ /exist/i;
  # 73 is EX_CANTCREAT
  exit 73 unless $! =~ /exist/i;
  $q2++;
}

# Now lock the file, so that the runner won't get to it.  If a runner does
# get to it, it will have zero size and thus the runner will unlock it
# quickly so we can just block here for a bit.
$ok = flock(OUT, $::LOCK_EX);

# Fill the queue file, skipping mailbox separator if present.
$abandoned = 0;
$line = <STDIN>;
print OUT $line unless $line =~ /^From /;
while (defined($line = <STDIN>)) {
  unless ($abandoned) {
    $ok = print OUT $line;
    $abandoned = 1 unless $ok;
  }
}
$ok = close OUT;  # Also unlocks.

# Better discrimination of errors is needed here.

# Since stdio is buffered, there is a chance that print()
# will succeed while close() fails for a small message.
# Returning EX_IOERR (74) will cause sendmail to regard the
# problem as a temporary failure and defer delivery.
unless ($ok) {
  # untaint
  $abandoned = "$qdir/$qfile";
  $abandoned =~ /(.*)/;
  $abandoned = $1;
  unlink $abandoned;
  exit 74;
}

logmsg "$opts{'P'}/$dom/$opts{'p'}/$qfunc/$qfile queued at " . time;

# Now start up the server.  We must exit 0 (or 99 for qmail) from here on
# out (no dying) because the file has already been queued and a runner will
# pick it up later.  From the MTA's standpoint, delivery was successful.

$rendezvous = "$::TMPDIR/mj_queueserv.sock";
unless (socket(SOCK, PF_UNIX, SOCK_STREAM, 0)) {
  logmsg "Couldn't create socket: $!";
  exit ($opts{'S'} ? 99 : 0);
}

if (!($ok = connect(SOCK, sockaddr_un($rendezvous)))) {
  # Couldn't connect to the server.  First, exclude other mj_enqueue
  # programs from starting one.
  open LOCK, ">> $::TMPDIR/mj_queueserv.lock" or
    die "Couldn't open lockfile $::TMPDIR/mj_queueserv.lock: $!";

  unless (flock(LOCK, $::LOCK_EX|$::LOCK_NB)) {
    logmsg "Another process is starting the server";
    exit ($opts{'S'} ? 99 : 0);
  }

  unless ($pid = fork) {
    unless (defined $pid) {
      warn "Couldn't fork: $!";
      exit ($opts{'S'} ? 99 : 0);
    }
    # Child...
    close STDOUT unless -t STDOUT;
    close STDERR unless -t STDOUT;
    close STDIN  unless -t STDOUT;
    exec "$::BINDIR/mj_queueserv", "$opts{'v'}";
    die "Couldn't exec $::BINDIR/mj_queueserv: $!";
  }
}

# Poll with linear backoff until server starts up
for ($i = 0; $i < 10 or die "connect: $!"; $i++) {
  last if $ok;
  sleep $i;
  close SOCK;
  unless (socket(SOCK, PF_UNIX, SOCK_STREAM, 0)) {
    warn "Couldn't create socket: $!";
    exit ($opts{'S'} ? 99 : 0);
  }
  $ok ||= connect(SOCK, sockaddr_un($rendezvous));
}

# Send a greeting to the server
out(*SOCK, "Hello.\n");

# Get a response
while ($line = in(*SOCK)) {
  logmsg "$line";
}

exit ($opts{'S'} ? 99 : 0);

# Look in $ENV{DEFAULT} which tells us the local-part of the address we're
# being run at, and fake the other options.  Expect that we were called
# with -d giving us the correct domain, so we don't have to fake that.
# Use $ENV{LOCAL} if $ENV{DEFAULT} does not exist.
sub do_qmail {
  my $addr;
  if(exists $ENV{DEFAULT}) {
    $addr = lc($ENV{DEFAULT});
  }
  else {
    $addr = lc($ENV{LOCAL});
  }
  if ($opts{T}) {
    $addr =~ s/^$opts{T}//;
    $addr =~ s/^-//;
  }

  my($list, $fun);

  # First look at majordomo addresses XXX These are hardcoded to
  # 'majordomo', but it would take too much time to load Majordomo.pm so
  # that we can extract the real majordomo address.
  if ($addr eq "$opts{'Q'}") {
    $opts{'m'} = 1;
    return;
  }
  if ($addr eq "$opts{'Q'}-owner" || $addr eq "owner-$opts{'Q'}") {
    $opts{'o'} = 1;
    return;
  }

  # Now assume we have a list address; look for owner-, -owner, -request.
  # Note breakage if the list name actually has any of these in it.
  if ($addr =~ /^owner-(.*)$/) {
    $list = $1; $fun = 'owner';
  }
  elsif ($addr =~ /^(.*)-moderator$/) {
    $list = $1; $fun = 'moderator'; 
  }
  # Note that we don't anchor to the end; we may be receiving a probe
  elsif ($addr =~ /^(.*)-owner$/) {
    $list = $1; $fun = 'owner'; 
  }
  elsif ($addr =~ /^(.*)-request$/) {
    $list = $1; $fun = 'request';
  }
  elsif ($addr =~ /^(.*)-subscribe$/) {
    $list = $1; $fun = 'subscribe';
  }
  elsif ($addr =~ /^(.*)-unsubscribe$/) {
    $list = $1; $fun = 'unsubscribe';
  }
  else {
    $list = $addr; $fun = 'list';
  }

  # Now we have the (supposed) list name.  Check that it exists by looking
  # directly into $::LISTDIR/$opts{'d'}.  Of course this assumes things
  # about the structure of the internal storage, but we have to trust that
  # or else go through some other expensive operations.  In this case, we
  # want to be quick.
  unless (-d "$::LISTDIR/$opts{'d'}/$list") {
    # It's not bound for us; just exit 0 so the next entry in
    # .qmail-default will be parsed.
    exit 0;
  }

  # XXX Addresses for auxiliary lists are not considered.
  # It is bound for us; fix up the options
  $opts{'l'} = $list;
  $fun eq 'list'        and $opts{'r'} = 1;
  $fun eq 'moderator'   and $opts{'M'} = 1;
  $fun eq 'owner'       and $opts{'o'} = 1;
  $fun eq 'request'     and $opts{'q'} = 1;
  $fun eq 'subscribe'   and $opts{'c'} = "subscribe";
  $fun eq 'unsubscribe' and $opts{'c'} = "unsubscribe";
}

# Make a directory safely.  Note that it's OK to fail because the directory
# already exists; some other enqueue program may be creating it at the same
# time as us.
sub smkdir {
  my $dir  = shift;
  my $mode = shift;
  unless (-d $dir) {
    $ok = mkdir $dir, $mode;
    unless ($ok) {
      die "Can't mkdir $dir: $!" if $! !~ /exists/;
    }
  }
}

=head1 NAME

mj_enqueue - Add a message to the incoming message queue.

=head1 SYNOPSIS

B<mj_enqueue>

=head1 DESCRIPTION

Blah.

=head1 COPYRIGHT

Copyright (c) 1999 Jason Tibbitts for The Majordomo Development
Group.  All rights reserved.

This program is free software; you can redistribute it and/or modify it
under the terms of the license detailed in the LICENSE file of the
Majordomo2 distribution.

his program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the Majordomo2 LICENSE file for more
detailed information.

=cut

#
### Local Variables: ***
### mode:cperl ***
### cperl-indent-level:2 ***
### End: ***
