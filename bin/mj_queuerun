#!/usr/local/bin/perl-latest -wT
BEGIN {
  $::LIBDIR = "/home/tibbs/mj/2.0/blib/lib";
  $::LISTDIR= "/home/tibbs/mj/2.0-lists";
  $::TMPDIR = "/tmp";
  $::LOCKDIR= "blah";
  $::UID    = "baduid";
  $::GID    = "badgid";
  $::UMASK  = "007";
  $::TIMEOUT= 30;

  $SIG{__WARN__} = sub {print STDERR "--== $_[0]"};

  # Redirect standard error output.
  if (! -t STDERR) {
    open (STDERR, ">>$::TMPDIR/mj_queuerun.debug") or
      die "Can't redirect debug output to $::TMPDIR/mj_queuerun.debug: $!";
  }

  # Croak if install was botched
  die("Not running as UID $::UID") unless $> == $::UID;
  die("Not running as GID $::GID") unless $) == $::GID;

  # Qyiet warning
  $::LOCKDIR;
}

=head1 NAME

mj_queuerun - process outstanding queue entries.

=head1 DESCRIPTION

When instructed, this program will go over every appropriately named file
in the queue directory and process it.  The server and the queueing program
are intended to be very small so that all the work can be done here.  This
program only exits after it has processed all outstanding queue files and
has had no new ones for some period of time.  This saves on compilation
time, which can get very expensive.

=cut
sub out { syswrite(STDOUT, $_[0], length($_[0]));}
sub in  { sysread(STDIN, $_, 1024); $_};

use lib "$::LIBDIR";
use Getopt::Std;
use strict;
my (%opts, $ein, $eout, $head, $line, $mime_parser, $mj, $nfound, $ok, 
    $request_ans, $rin, $rout, $win, $wout);

umask oct($::UMASK);

$ENV{'PATH'} = "/bin:/usr/bin:/usr/ucb"; # Needed for Syslog to get hostname.

# Parse the command line arguments.
# -t - specify directory containing domains (arg)
# -v - specify debug verbosity (arg), default 50.

getopts('t:v:', \%opts);

# We must untaint the top level dir and the domain because they are used to
# generate filenames; it's safe since they were supplied by the site owner.
$opts{t} ||= $::LISTDIR;
$opts{t} =~ /(.*)/;
$opts{t} = $1;
$opts{v} ||= 0;

# Pull in the logging module
eval 'use Mj::Log';

# Open a log
$::log = new Mj::Log;
$::log->add
  (
   # If we can pront the messages somewhere, print them, else we dump them
   # to syslog.
#   method      => (-t STDERR)?'handle':'syslog',
   method      => 'handle',
   handle      => \*STDERR,
   id          => 'mjqr',
   level       => ($opts{v} =~ /^(\d+)$/)[0] || 50,
   subsystem   => 'mail',
   log_exits   => 1,
   log_entries => 1,
   log_args    => 1,
  );

$::log->in(20, undef, "info", "Majordomo queue runner - ".scalar(localtime));
$::log->startup_time();

# Now pull in the rest of the modules we need.  This is delayed until after
# compile time in order to make qmail checking fast if we were called but
# we do not handle the address.
$::log->in(21, undef, 'info', 'Loading modules');
eval '
  use Fcntl ":flock";
  use Majordomo;
  use Mj::Parser;
  use Mj::Deliver::Envelope;
  use Mj::MIMEParser;
  use Mj::CommandProps qw(command);
  use Data::Dumper;
  use IO::File;
#  use Devel::Symdump;
';
$::log->out;

# Now, we're ready.
out('Starting');

# Loop forever
while (1) {
  # Select on standard input, which is our signal to go.
  $rin = $win = $ein = ''; vec($rin,fileno(STDIN),1) = 1; $ein = $rin | $win;
  $nfound = select($rout=$rin, $wout=$win, $eout=$ein, $::TIMEOUT);
  unless ($nfound) {
    $::log->out('Timed out');
    last;
  }

  $line = in();
  unless (defined $line && length $line) {
    $::log->message(50, 'info', "Read undef or empty line; server must have died.");
    last;
  }
  if ($line =~ /(Ping \d+)$/) {
    # The server is pinging us to see if we're alive.  Return the ping and
    # wait again.  This lets the server know that we're just sitting here
    # and to refresh the timeout.  We chop off all but the last bit because
    # the server may have pinged us multiple times.
    out($1);
    next;
  }
  out('Running queue');
  run_queue();
}
out('Exiting');
exit;

sub run_queue {
  my $log = new Log::In 25, 'Running queue';
  my(@domains, @functions, @pri1, @pri2, $arg, $debug1, $debug2, $dom, $file,
     $func, $list, $mj, $msg, $ok, $pri1, $pri2, $start, $end,
     @fhstatus, @status);

  # Grab the domain priorities from the queue, high priorities first
  opendir(PRI1, "$::LISTDIR/QUEUE") ||
    $::log->abort("Can't opendir $::LISTDIR/QUEUE: $!");
  @pri1 = sort {$b <=> $a} grep { $_ !~ /^\./ } readdir PRI1;
  closedir PRI1;

  # Loop over domain priorities
  for $pri1 (@pri1) {
    $pri1 =~ /(.*)/; $pri1 = $1;

    # Grab the domains from the queue
    opendir(DOMS, "$::LISTDIR/QUEUE/$pri1") ||
      $::log->abort("Can't opendir $::LISTDIR/QUEUE/$pri1: $!");
    @domains = grep { $_ !~ /^\./ } readdir DOMS;
    closedir DOMS;

    # XXX Ramdomize domain list to avoid starvation

    # Loop over domains
  DOM:
    for $dom (@domains) {
      # Untaint $dom; this is safe because only we are able to write to that
      # directory.
      $dom =~ /(.*)/; $dom = $1;

#      $start = Devel::Symdump->rnew();

      # Grab list priorities from the queue, high priorities first
      opendir(PRI2, "$::LISTDIR/QUEUE/$pri1/$dom") ||
    $::log->abort("Can't opendir $::LISTDIR/QUEUE/$pri1/$dom: $!");
      @pri2 = sort {$b <=> $a} grep { $_ !~ /^\./ } readdir PRI2;
      closedir PRI2;

      # Loop over list priorities
      for $pri2 (@pri2) {
    $pri2 =~ /(.*)/; $pri2 = $1;

    # Grab the functions from the queue
    opendir(FUNCS, "$::LISTDIR/QUEUE/$pri1/$dom/$pri2") ||
      $::log->abort("Can't opendir $::LISTDIR/QUEUE/$pri1/$dom/$pri2: $!");
    @functions = grep { $_ !~ /^\./ } readdir FUNCS;
    closedir FUNCS;

    # XXX Randomize function list to avoid starvation???

    # Loop over functions
      FUNC:
    for $func (@functions) {
      # Untaint $func; this is safe because only we are able to write to
      # that directory.
      $func =~ /(.*)/; $func = $1;

      # Grab the queue files from the queue
      opendir(QDIR, "$::LISTDIR/QUEUE/$pri1/$dom/$pri2/$func") ||
        $::log->abort("Can't opendir $::LISTDIR/QUEUE/$pri1/$dom/$pri2/$func: $!");

      # Loop over queue files (no need to randomize; they're in a random
      # order and there may be many of them)
    MSG:
      while (defined($msg = readdir QDIR)) {
        next MSG if $msg =~ /^\./;

        # Untaint $msg; this is safe because only we are able to write
        # stuff in that directory
        $msg =~ /(.*)/; $msg = $1;
        $file = "$::LISTDIR/QUEUE/$pri1/$dom/$pri2/$func/$msg";
        unless (open(MSG, "+< $file")) {
          # Some other runner may have deleted the file while we were
          # iterating through the directory.  That's OK; note it and go
          # on.
          $log->message(20, 'info', "Can't open queue file $file: $!");
          next MSG;
        }

        # Lock a file, non-blocking; next if we didn't get it.
        $ok = flock(MSG, &LOCK_EX|&LOCK_NB);
        unless ($ok) {
          close MSG;
          next MSG;
        }
        @fhstatus = stat MSG;
        @status = stat $file;
        # Make sure file has nonzero size to avoid a race with mj_enqueue
        # Make sure no modification has occurred to the file 
        # between open() and flock().
        unless ($status[7] && (@status eq @fhstatus) && (-r $file)) {
          close MSG;
          next MSG;
        }

        # OK, have something to process.  Lazily create a Majordomo object
        # for the domain we're processing.
        unless (defined $mj) {
          $::mj = new Majordomo $opts{t}, $dom; $mj = $::mj;
          unless (ref $::mj) {
        $::log->abort("Cannot create Majordomo object: $::mj");
          }
          $debug1 = $mj->global_config_get(undef, undef, 'debug');
          if ($opts{'v'} > $debug1) {$debug1 = $opts{'v'}};
          $::log->set_level($debug1);
        }

        # If we're at the Majordom address, just parse commands
        if ($func eq 'majordomo') {
          $log->message(50, 'info', 'Processing commands');
          debug_to('majord');
          parse_commands($mj);
          debug_to('queuerun');
          unlink $file;
          close MSG;
          next MSG;
        }

        # Messages to the Majordomo owner address don't have a list on
        # the end
        if ($func eq 'owner' && $msg =~ /^\w\w\w-\d+$/) {
          $log->message(50, 'info', 'Forwarding to majordomo-owner');
          debug_to('owner');
          forward_to_owner($mj, 'GLOBAL');
          debug_to('queuerun');
          unlink $file;
          close MSG;
          next MSG;
        }

        # Else we have something that is associated with a list;
        # extract the list name
        $msg =~ /^\w\w\w-\d+-([^,]*),?([^,]*)$/; 
        $list = $1; 
        $arg  = $2 || '';

        # Now set the logging level to that of the list.
        $debug2 = $mj->list_config_get(undef, undef, $list, 'debug');
        if ($debug1 > $debug2) {$debug2 = $debug1};
        $::log->set_level($debug2);

        # Perform the appropriate function
        # If at list address, resend.
        if ($func eq 'list' || $func eq 'resend') {
          $log->message(50, 'info', 'Posting message');
          debug_to('resend');
          resend($mj, $list, $file, $arg);
          debug_to('queuerun');
        }

        # if at -request pull out global 'request_answer' variable and
        # figure out what to do
        elsif ($func eq 'request') {
          $request_ans = $mj->global_config_get(undef, undef, 'request_answer');
          if ($request_ans eq 'majordomo') {
        $log->message(50, 'info', 'Processing commands');
        debug_to('majord');
        parse_commands($mj, $list, $arg);
        debug_to('queuerun');
          }
          elsif ($request_ans eq 'owner') {
        $log->message(50, 'info', 'Forwarding to owner');
        debug_to('owner');
        forward_to_owner($mj, $list);
        debug_to('queuerun');
          }
          else {
        $log->message(50, 'info', 'Responding with file');
        debug_to('request');
        respond_with_file($mj, $list);
        debug_to('queuerun');
          }
        }

        # if at -owner look for bounces and forward everything else to the
        # owner
        elsif ($func eq 'owner') {
          # forward to owner; if -l is present, forward to that list else assume
          # we're majordomo-owner.
          $log->message(50, 'info', 'Forwarding to owner');
          debug_to('owner');
          forward_to_owner($mj, $list || 'GLOBAL', $arg);
          debug_to('queuerun');
        }

        # Remove the file, but keep in mind that it may have already
        # been moved to some other location (if it was spooled, for
        # instance).
        if (-s $file) {
          unlink $file; 
        }
        close MSG;
        $::log->set_level($debug1);
      } # $msg
      closedir QDIR;
    } # $func
      } # $pri2
      # undef Majordomo object
      if ($mj) {
    $::log->message(50, "info", "-----Calling destructors-----");
    undef $mj;
    undef $::mj;
      }
#      $end = Devel::Symdump->rnew();
#      warn($start->diff($end));
    } # $dom
  } # $pri1
} # sub run_queue

# Forward the message to the list owner.  Call owner_start, owner_chunk,
# owner_done passing in all of the message.
sub forward_to_owner {
  my ($mj, $list, $moderator) = @_;
  my ($ok, $mess, $sess, $request);

  # If the message was sent to the -moderator alias, $moderator will be 'M'
  $moderator ||= '';

  $sess = connect_no_parse($mj, 'owner');
  return unless $sess;

  # Some MTAs hand the message to us with the mbox separator prepended.
  # Sending this on as part of the headers can hose some MTAs, so we strip
  # it.  The regexp doesn't harm the body $sess contains only the headers.
  $sess =~ s/^From .*?\r?\n//;
  $request = {
    'command'   => 'owner_start',
    'list'      => $list,
    'mode'      => $moderator,
    'password'  => '',
    'user'      => '',
  };
  ($ok, $mess) = @{$mj->dispatch($request)};
  return unless $ok;

  $request->{'command'} = 'owner_chunk';
  $_ = $sess;
  while (1) {
    last unless defined $_;
    ($ok, $mess) = @{$mj->dispatch($request, $_)};
    return unless $ok;
    $_ = <MSG>;
  }
  $request->{'command'} = 'owner_done';
  ($ok, $mess) = @{$mj->dispatch($request)};
  return unless $ok;
  1;
}

# Resend a message; call post but instead of doing the copy operation, just
# use the spooled message.  #XXX Beware of who gets to unlink it.
sub resend {
  my ($mj, $list, $file, $sublist) = @_;
  my ($ok, $mess, $request, $sess);

  $sess = connect_no_parse($mj, 'resend');
  return unless $sess;

  # Some MTAs hand the message to us with the mbox separator prepended.
  # Sending this on as part of the headers can hose some MTAs, so we strip
  # it.  The regexp doesn't harm the body $sess contains only the headers.
  $sess =~ s/^From .*?\r?\n//;

  $sublist ||= '';
  $request = {
    'auxlist'   => $sublist,
    'command'   => 'post',
    'file'      => $file,
    'list'      => $list,
    'mode'      => '',
    'password'  => '',
    'user'      => '',
  };

  ($ok, $mess) = @{$mj->dispatch($request)};
  return unless $ok;
  1;
}

# Just call the request_response method.
sub respond_with_file {
  my ($mj, $list) = @_;
  my ($request, $user);
  ($list, undef) = split ',', $list;
  
  (undef, undef, $user) = connect_and_parse($mj, 'request');
  $request = {
    'command'   => 'request_response',
    'list'      => $list,
    'mode'      => '',
    'password'  => '',
    'user'      => $user,
  };

  $mj->dispatch($request);
  1;
}

# These two functions exist because there are times when we can avoid
# loading the MIME modules in the client.  To connect, all we need is the
# header of the incoming message.  If we do no MIME parsing here (such as
# when we're forwarding to the owner or resending) we can just pull in
# everything until the first blank line.

# This pulls in the header, connects to the given majordomo object, and
# returns the header _including_ the first blank line.  Standard input will
# contain the remainder of the message.
sub connect_no_parse {
  my ($mj, $int) = @_;
  my ($i, $id, $sess);

  while (defined($i = <MSG>)) {
    if ($i =~ /^\r?\n/) {
      $id = $mj->connect($int, $sess, 'unknown@anonymous');
      return unless $id;
      $sess .= $i;
      last;
    }
    $sess .= $i;
  }
  $sess;
}

# This parses the message and connects to the provided Majordomo object.
# The MIME entity, unfolded header and user/reply address (stripped and
# unstripped) will be returned.
sub connect_and_parse {
  my ($mj, $int) = @_;
  my($entity, $head, $mime_parser, $ok, $user, $suser);

  $::log->in(85, undef, "info", "Setting MIME parser properties");
  $mime_parser = new Mj::MIMEParser;
  $mime_parser->output_to_core($mj->global_config_get(undef, undef, 
                              "max_in_core"));
  $mime_parser->output_dir($::TMPDIR);
  $mime_parser->output_prefix("mje");
  $::log->out;

  # One line does all of the parsing!
  $::log->in(80, undef, "info", "Taking apart the incoming message");
  $entity = $mime_parser->read(\*MSG);
  $::log->out;

  return unless $entity; 
  
  # Get the header.
  $::log->in(80, undef, "info", "Parsing the header");
  $head = $entity->head;
  $head->unfold;
  $::log->out;

  $user = $head->get('from') || $head->get('apparently-from');
  chomp $user;

  unless ($user) {
    $entity->purge;
    return;
  }

  # Connect; gives back the stripped user
  ($ok, $suser) = $mj->connect($int, $entity->head->as_string, $user);

  # Connect can now fail: 0: try again later, undef: bomb with error, > 0:
  # connection ID

  # If it failed, just clean up and return.  XXX We probably should warn
  # the owner here.
  unless (defined($ok)) {
    $entity->purge;
    return;
  }
  
  ($entity, $head, $suser, $user);
}

# Parse commands in the subject here; we do this early to get the debug log
# going.  XXX Support ACCEPT, REJECT, LIST and PASS in the subject, too.  The
# first two for quick confirmation token processing; the latter two for
# bypassing failed "access" checks.
sub parse_commands {
  my ($mj, $deflist, $command) = @_;
  my (@entities, $args, $av, $debug_file, $debug_log,
      $debug_reply, $entity, $fh, $file, $head, $i, $line, $list, $ok, 
      $request, $sender, $sub_addin, $subject, $tag, $tlist, $top, 
      $token, $user, $uuser);

  ($entity, $head, $user, $uuser) = connect_and_parse($mj, 'email');
  return unless $entity;
  $subject = $head->get('subject') || "";

  # Look for a possible token
  $token = $mj->t_recognize($subject);

  if ($subject =~ s/DEBUG\s*(\d+)\s*//) {
    $debug_reply = $1;
    $debug_file  = "$::TMPDIR/mje.$$.debug";
    $debug_log =
      $::log->add(method      => 'file',
          filename    => $debug_file,
          id          => 'mje',
          level       => $debug_reply,
          subsystem   => 'mail',
          log_entries => 1,
          log_exits   => 1,
          log_args    => 1,
         );
  }

  $::log->message(35, "info", "Message from $user.");
  
  # Need to bail if we're talking to ourselves, either here (it's convenient)
  # or when checking access.
  
  if ($mj->global_config_get(undef, undef, 'return_subject') &&
      defined($head->get('subject')) && $head->get('subject') =~ /\S/)
    {
      $sub_addin = ': ' . (substr($head->get('subject'), 0, 40));
      chomp $sub_addin;
    } 
  else {
    $sub_addin = '';
  }

  # -subscribe and -unsubscribe aliases have the command in
  # the queue file name.  The message body is not parsed.
  if (defined $command and Mj::CommandProps::command_legal($command)) {
    # Iterated or aliased commands are not yet considered.
    $request = {
      'command'   => $command,
      'list'      => $deflist,
      'mode'      => '',
      'password'  => '',
      'user'      => $uuser,
    };
    $file = &Majordomo::tempname();
    $fh = new IO::File "> $file";
    if (defined $fh) {
      no strict 'refs';
      &{"Mj::Format::$command"}($mj, $fh, $fh, 'text', $request,
                           $mj->dispatch($request));
    }
    $fh->close;
    push @entities, build MIME::Entity
      (
       'Path'        => $file,
       '-To'         => $uuser,
      );
  }
  else {  
    (undef, @entities) = 
      Mj::Parser::parse_entity($mj,
                   tmpdir     => $::TMPDIR, 
                   entity     => $entity,
                   reply_to   => $uuser,
                   deflist    => $deflist,
                   token      => $token,
                  );
  }

  if ($debug_reply) {
    push @entities, build MIME::Entity
      (
       Path        => $debug_file,
       Description => "Debugging information",
       Top         => 0,
      );
  }
  
  # Somehow we need to put together all of the entities and the debug info.
  # If we just have one entity, we add the necessary headers and send it
  # (this avoids attaching useless MIME crap).  If we have multiple
  # entities then we build a top and attach them all to it.
  if (@entities == 1) {
    $top = shift @entities;
    # XXX This is nasty, because MIME-Tools might start supporting a newer
    # MIME version at any time, but we have to do this until we get
    # MIME::Entity::make_top.
    $top->head->replace('MIME-Version', '1.0');
  }
  else {
    $top = build MIME::Entity
      Type => "multipart/mixed";
    
    for $i (@entities) {
      $top->add_part($i);
    }
  }

  $head = $top->head;
  $head->replace('to'      , $uuser);
  $head->replace('subject' , "Majordomo results$sub_addin");
  $head->replace('from'    , $mj->global_config_get(undef, undef, 'whoami_owner'));
  $head->replace('reply-to', $mj->global_config_get(undef, undef, 'whoami'));
  
  $sender = $mj->global_config_get(undef, undef, 'sender');
  $::log->delete($debug_log) if defined $debug_log;
  open(BLAH, ">$::TMPDIR/mje.$$.final") ||
    $::log->abort("Couldn't open final output file, $!");
  $top->print(\*BLAH);
  close BLAH;
  
  $mj->mail_message($sender, "$::TMPDIR/mje.$$.final", $user);
  
  # Purge all tempfiles created by the entities.  XXX Ugh, need to clean up
  # the variable names.
  $entity->purge;
  $top->purge;
  unlink "$::TMPDIR/mje.$$.final";
}

sub debug_to {
  my $name = shift;

  if (! -t STDERR) {
    close STDERR;
    open STDERR, ">>$::TMPDIR/mj_$name.debug" or
      die "Can't redirect debug output to $::TMPDIR/mj_$name.debug: $!";
  }
}

=head1 COPYRIGHT

Copyright (c) 1999 Jason Tibbitts for The Majordomo Development Group.  All
rights reserved.

This program is free software; you can redistribute it and/or modify it
under the terms of the license detailed in the LICENSE file of the
Majordomo2 distribution.

his program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the Majordomo2 LICENSE file for more
detailed information.

=cut

#
### Local Variables: ***
### cperl-indent-level:2 ***
### End: ***
