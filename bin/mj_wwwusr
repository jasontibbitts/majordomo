#!/usr/local/bin/perl-latest -wT
BEGIN {
  $::LIBDIR = 'unset';
  $::LISTDIR= 'unset';
  $::TMPDIR = 'unset';
  $::LOCKDIR= "blah";
  $::UMASK  = "007";
  $SIG{__WARN__} = sub {print STDERR "--== $_[0]"};

  # Redirect standard error output.
  if (! -t STDERR) {
    open (STDERR, ">>$::TMPDIR/mj_wwwusr.debug");
  }
}

=head1 NAME

mj_wwwusr - demonstration of majordomo user interface .

=head1 SYNOPSIS

Extend this file to create specialized CGI scripts.

=head1 DESCRIPTION

When utilizing majordomo with a CGI script, there are
several basic steps that must be taken, including initializing
majordomo variables,  creating a log (STDERR by default), 
initializing a CGI object, and starting a majordomo session
with connect().

This script performs these basic steps, easing the 
creation of new CGI scripts.  Adapt it to suit your needs.

Note that it may be necessary to install a setuid wrapper
for any script based upon this example.

=cut
use lib "$::LIBDIR";
use strict;
use CGI;
use Majordomo;
use Mj::Addr;
use Mj::CommandProps qw(:function);
use Mj::Format;
use Mj::Log;
use Mj::Parser;

my (%commands, @domains, @lists, $addr, $cgi, $cgidata, $cgiurl, 
    $domain, $extra, $falseuser, $func, $list, $mj, $mess, $mode, 
    $ofunc, $ok, $opass, $part, $passw, $pathinfo, $raw, $request, 
    $result, $sess, $str, $subs, $tmp, $user);

#----- Which commands are supported  -----#
# First  value:  Is a password required?
# Second value:  Is a valid address required?
# Third  value:  Is a list required?
# Fourth value:  Should the result be preformatted?
# Fifth value:  Page to display after the result.
%commands = (   
                'alias'         => [1, 1, 0, 1, 'show'],
                'archive'       => [0, 0, 1, 0, 'list'],
                'changeaddr'    => [1, 1, 0, 1, 'show'],
                'faq'           => [0, 0, 1, 0, 'list'],
                'help'          => [0, 0, 0, 1, 'help'],
                'info'          => [0, 0, 1, 0, 'list'],
                'intro'         => [0, 0, 1, 0, 'list'],
                'lists'         => [0, 0, 0, 0, 'lists'],
                'password'      => [0, 1, 0, 1, 'login'],
                'register'      => [0, 1, 0, 0, 'welcome'],
                'set'           => [1, 1, 1, 0, 'show'],
                'show'          => [1, 1, 0, 0, 'show'],
                'subscribe'     => [0, 1, 1, 0, 'list'],
                'unalias'       => [1, 1, 0, 1, 'show'],
                'unregister'    => [1, 1, 0, 0, 'welcome'],
                'unsubscribe'   => [1, 1, 1, 0, 'show'],
                'welcome'       => [0, 0, 0, 0, 'welcome'],
            );
             
#----- Initialize the Log -----#
&initialize_log;

#----- Initialize the CGI object -----#
$cgi = new CGI;

$pathinfo = $domain = '';
if (exists $ENV{'PATH_INFO'}) {
  $pathinfo = $ENV{'PATH_INFO'};
  while ($pathinfo =~ s#/domain=([a-zA-Z0-9.-]+)##) {
    $domain = $1;
  }

  $pathinfo =~ s#^/+##;
  $pathinfo =~ s#/+$##;
  if ($pathinfo =~ m#(.+\@[^/]+)#) {
    $pathinfo = $1;
  }
  else {
    $pathinfo = '';
  }
}

unless ($domain) {
  $domain = $cgi->param('domain') || '';
}

# Clean up the URL by which this program was invoked.
$cgiurl = $cgi->script_name;
if ($domain) {
  $cgiurl .= "/domain=$domain";
}
if ($pathinfo) {
  $cgiurl .= "/$pathinfo";
}
$cgiurl = Mj::Format::uescape($cgiurl);

unless ($domain) {
  @domains = Majordomo::domains($::LISTDIR);
  ($domain) = grep { lc $_ eq lc $ENV{'HTTP_HOST'} } @domains;
  $domain = $domains[0] unless $domain;
}

# Untaint the domain name.
if ($domain =~ /([a-zA-Z0-9\.\-]+)/) {
  $domain = $1;
}
else {
  &surrender(qq("$domain" is an invalid domain.), $cgi);
}

#----- Make the Majordomo object -----#
$mj = new Majordomo $::LISTDIR, $domain;
&surrender($mj, $cgi) unless (ref $mj);

#----- Generate the session information. -----#
for my $i ('REMOTE_ADDR','REMOTE_PORT', 'PATH_INFO') {
  $sess .= "X-$i: $ENV{$i}\n" if defined $ENV{$i};
}
$sess .= "Date: " . scalar(localtime(time)) . "\n";

#----- Determine the address of the user. -----#
$falseuser   = "x$ENV{'REMOTE_ADDR'}\@example.com";
$user    = $cgi->param('user') || $pathinfo || $falseuser;

#----- Connect to the server -----#
($ok, $mess) = $mj->connect('wwwusr', $sess, $user);

unless ($ok) {
  $subs = { $mj->standard_subs('GLOBAL'),
            'CGIDATA'  => '',
            'CGIURL'   => $cgi->script_name,
            'CMDPASS'  => '',
            'COMMAND'  => 'welcome',
            'DOMAIN'   => $domain,
            'USER'     => ($falseuser eq $user) ? '':
                          Mj::Format::escape($user),
        };

  &login($mj, $subs, $mess);
}

#----- Create a temporary password -----#
$opass = $passw = $cgi->param('passw') || '';
if (length $opass) {
  $opass =~ /(\S+)/; $passw = $1;
  $passw = $mj->gen_latchkey($passw) 
    unless ($mj->t_recognize($passw));
}

$ofunc = $cgi->param('func') || 'welcome';

$cgidata = Mj::Format::cgidata($mj, { 'password' => $passw,
                                      'user'     => $user });

$subs = { $mj->standard_subs('GLOBAL'),
          'CGIDATA'  => $cgidata,
          'CGIURL'   => $cgiurl,
          'CMDPASS'  => $passw,
          'COMMAND'  => $ofunc,
          'DOMAIN'   => $domain,
          'USER'     => ($falseuser eq $user) ? '':
                        Mj::Format::escape($user),
        };

#----- Determine what service was requested -----#
# Extract "mode" from command name
if ($ofunc =~ /([^\s=-]+)[=-](.*)/) {
  $func = $1;
  $mode = $2;
}
else { 
  $ofunc =~ /(.*)/; $ofunc = $1;
  $func = $ofunc;
  $mode = '';
}

$raw = 0;
if ($func eq 'archive' and $mode =~ /get/ and $mode =~ /part/) {
  $raw = 1;
}

if ($func eq 'logout') {
  $mj->del_latchkey($passw);
  $subs->{'CMDPASS'} = '';
  $subs->{'COMMAND'} = 'welcome';
  &usage($mj, $subs, 'You have successfully signed out.');
}
elsif ($func eq 'login') {
  $subs->{'COMMAND'} = 'welcome';
  &login($mj, $subs, '');
}

if ($func eq 'archive' and $mode =~ /get/ and ! $raw) {
  $mode .= $mode? "-immediate" : "immediate";
}

# Make sure the command is valid
unless (exists $commands{$func}) {
  &usage($mj, $subs, "$func is an unsupported command.");
}

#----- Address check -----#
$addr = new Mj::Addr($user);

($ok, $mess) = $addr->valid;
unless ($ok) {
  &login($mj, $subs, "The address $user is invalid.\n$mess\n");
}

$tmp = $cgi->param('name');
if (defined $tmp and $tmp =~ /\S/) {
  ($ok, $mess) = $addr->setcomment($tmp);
  unless ($ok) {
    &login($mj, $subs, "The name $tmp is invalid.\n$mess\n");
  }
}

if ($commands{$func}->[1] and (!$user or $user =~ /example\.com$/i)) {
  &login($mj, $subs, "The address \"$user\" is invalid.");
}

#----- Password check -----#
if (! $passw) {
  &login($mj, $subs, "A password is required to use the $func command.")
    if ($commands{$func}->[0]);
}
else {
  unless ($mj->validate_passwd($addr, $passw, 'GLOBAL', 'show')) {
    if ($mj->t_recognize($opass)) {
      $subs->{'CMDPASS'} = '';
      &login($mj, $subs, '');
    }
    $subs->{'CMDPASS'} = '';
    &login($mj, $subs, $mj->format_error('invalid_password',
                         'GLOBAL', 'VICTIM' => $user));
  }
}

if ($ofunc eq 'welcome') {
  &usage($mj, $subs, '');
}

#----- List check -----#
@lists   = $cgi->param('list');
if ($commands{$func}->[2] and ! scalar @lists) {
  &usage($mj, $subs, 
         "A mailing list must be provided to use the \"$func\" command.");
}
$lists[0] ||= 'GLOBAL';
  

#----- Construct the request -----#
$request = {
  'cgidata'   => $cgidata,
  'cgiurl'    => $cgiurl,
  'command'   => $func,
  'list'      => $lists[0],
  'mode'      => $mode,
  'password'  => $passw,
  'user'      => $addr,
};
if (function_prop($func, 'iter')) {
  $request->{'command'} .= '_start';
}

$extra   = $cgi->param('extra') || '';

#----- For changeaddr to work, the user and victim must be exchanged. -----#
if ($func eq 'changeaddr') {
  $request->{'user'} = $extra;
  $extra = $user;
}
  
no strict 'refs';
#----- Convert the arguments into the appropriate request values -----#
Mj::Parser::parse_args ($request, $extra, '') if ($extra);

#----- Print the generic page header -----#
unless ($raw) {
  print $cgi->header(-expires => '+10s');
  $tmp = $mj->format_get_string('wwwusr', 'head');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";
}

for $list (@lists) {
  $request->{'list'} = $list;
  # For the 'set' command, convert the CGI data into the appropriate settings.
  if ($func eq 'set') {
    my ($i, $j, @params, @settings);
    @params = $cgi->param;
    for $j (qw(delivery ackdeny ackpost ackreject ackstall eliminatecc
               hideaddress hideall hidepost prefix replyto selfcopy 
               rewritefrom)) {
      $i = "$list;$j";
      if ($j eq 'delivery') {
        push @settings, $cgi->param($i);
      }
      else {
        if (! $cgi->param($i)) {
          push @settings, "no$j";
        }
        elsif ($cgi->param($i) eq 'on') {
          push @settings, $j;
        }
        # If the setting is disabled, ignore it.
      }
    }
    $request->{'setting'} = join ",", @settings;
  }
  elsif ($func eq 'password') {
    $tmp = $cgi->param('newpasswd');
    $tmp =~ s/\s+//g;
    if (defined $tmp and length $tmp) {
      Mj::Parser::parse_args ($request, $tmp, '');
    }
    else {
      $request->{'mode'} = 'gen';
    }
    $subs->{'CMDPASS'} = '';
    $subs->{'COMMAND'} = 'show';
  }
  elsif ($func eq 'unalias') {
    $tmp = $cgi->param('alias');
    $tmp =~ s/\s+//g;
    if (defined $tmp and length $tmp) {
      Mj::Parser::parse_args ($request, $tmp, '');
    }
  }

  $result = $mj->dispatch($request); 
  &usage($mj, $subs, "Unable to obtain result from Majordomo.") unless $result;

  # Display part of a message when the archive-get-part command is used.
  if ($raw) {
    $part = $request->{'part'};

    if (! $result->[0] or $part eq '0') {
      print $cgi->header(-expires => '+10s');
      $tmp = $mj->format_get_string('wwwusr', 'head');
      $str = $mj->substitute_vars_format($tmp, $subs);
      print STDOUT "$str\n";
      $raw = 0;
    }
    elsif ($part =~ /[hH]$/) {
      print $cgi->header('-type' => 'text/plain', '-expires' => '+10s');
    }
    else {
      $tmp = $result->[1]->[2]->{$part}->{'type'} || 'text/plain';
      print $cgi->header('-type' => $tmp, '-expires' => '+10s');
    }
  }

  print "<pre>\n" if ($commands{$func}->[3]);
  &{"Mj::Format::$func"}($mj, \*STDOUT, \*STDOUT, 'wwwusr', $request, $result);
  print "</pre>\n" if ($commands{$func}->[3]);;
}

#----- Display supplementary information -----#
# There are five supplementary screens which this script displays. 
#   list - Information about a single mailing list
#   lists - Information about all public mailing lists
#   login - Prompt for an e-mail address and password
#   show - Personal information about a subscriber
#   welcome - A help file that describes how to use the interface.

if ($commands{$func}->[4] ne $func and $ofunc ne 'set-check') {
  if ($func eq 'changeaddr') {
    # restore original user if changeaddr did not succeed.
    $request->{'user'} = $user if ($result->[0] < 1);
    undef $request->{'victim'};
    undef $request->{'victims'};
  }

  if ($cgi->param('brief') or $raw) {
    # Display nothing.
  }
  elsif ($commands{$func}->[4] eq 'list') {
    $request->{'command'} = 'lists';
    $request->{'mode'} = 'full-long';
    $request->{'list'} = 'GLOBAL';
    for $list (@lists) {
      $request->{'regexp'} = $list;
      $result = $mj->dispatch($request); 
      &usage($mj, $subs, "Unable to obtain result from Majordomo.") 
        unless $result;
      &Mj::Format::lists($mj, \*STDOUT, \*STDOUT, 'wwwusr', $request, $result);
    }
  }
  elsif ($commands{$func}->[4] eq 'lists') {
    $request->{'command'} = 'lists';
    $request->{'mode'} = '';
    $request->{'list'} = 'GLOBAL';
    $result = $mj->dispatch($request); 
    &usage($mj, $subs, "Unable to obtain result from Majordomo.") 
      unless $result;
    &Mj::Format::lists($mj, \*STDOUT, \*STDOUT, 'wwwusr', $request, $result);
  }
  elsif ($commands{$func}->[4] eq 'show') {
    $func = $request->{'command'} = 'show';
    $result = $mj->dispatch($request); 
    &usage($mj, $subs, "Unable to obtain result from Majordomo.") 
      unless $result;
    &Mj::Format::show($mj, \*STDOUT, \*STDOUT, 'wwwusr', $request, $result);
  }
  elsif ($commands{$func}->[4] eq 'welcome') {
    &usage($mj, $subs, '');
  }
  elsif ($commands{$func}->[4] eq 'login') {
    &login($mj, $subs, '');
  }
  # Fall through for unexpected cases.
}

#----- Print the Footer -----#
unless ($raw) {
  $tmp = $mj->format_get_string('wwwusr', 'foot');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";
}

#----- Subroutines -----#

sub initialize_log {  
  $ENV{'PATH'} = "/bin:/usr/bin:/usr/ucb";
  umask oct($::UMASK);
  # Change the log level to a higher number (500) for complete debugging
  $::log = new Mj::Log;
  $::log->add
    (
     method      => 'handle',
     id          => 'wwwusr',
     handle      => \*STDERR,
     level       => 50,
     subsystem   => 'mail',
     log_entries => 1,
     log_exits   => 1,
     log_args    => 1,
    );

  $::log->in(20, undef, "info", "Majordomo 2 WWW User Interface - " .
                                 scalar(localtime) .
                                 " from $ENV{'REMOTE_ADDR'}");
  $::log->startup_time();
}

sub login {
  my ($mj, $subs, $message) = @_;
  my ($str, $tmp);

  $subs->{'ERROR'} = $message;
  $::log->message(50, "info", $message) if $message;

  print $cgi->header(-expires => '+10s');
  $tmp = $mj->format_get_string('wwwusr', 'head');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";

  $tmp = $mj->format_get_string('wwwusr', 'login');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";

  $tmp = $mj->format_get_string('wwwusr', 'foot');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";
  
  exit 1;
}

sub usage {
  my ($mj, $subs, $message) = @_;
  my ($str, $tmp);

  $subs->{'ERROR'} = $message;
  $::log->message(50, "info", $message) if $message;

  print $cgi->header(-expires => '+10s');
  $tmp = $mj->format_get_string('wwwusr', 'head');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";

  $tmp = $mj->format_get_string('wwwusr', 'welcome');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";

  $tmp = $mj->format_get_string('wwwusr', 'foot');
  $str = $mj->substitute_vars_format($tmp, $subs);
  print STDOUT "$str\n";
  
  exit 1;
}

sub surrender {
  my ($message, $cgi) = shift;
  $::log->message(50, "info", $message) if $message;
  my ($url) = $cgi->script_name;

  print $cgi->header(-expires => '+10s');

  print <<EOM;
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
"http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head>
<title>Majordomo 2 WWW for Subscribers: Error</title>
</head>
<body>
<h2 align=center>Majordomo Error</h2>
$message
<form method=POST action="$url">
  <input type=hidden name=func value="login">
  Enter the domain name into the box, then press the <b>Sign In</b> button.<br>
  <input name=domain size=45>
  <input type=submit value="Sign In">
</form>
EOM

  if (defined $subs and exists $subs->{'MJOWNER'}) {
    print <<EOM;
Please contact 
<a href="mailto:$subs->{'MJOWNER'}">$subs->{'MJOWNER'}</a>
 for assistance.
EOM
  }

print "</body></html>\n";

  exit 0;
}


=head1 COPYRIGHT

Copyright (c) 2000, 2002 Jason Tibbitts for The Majordomo Development
Group.  All rights reserved.

This program is free software; you can redistribute it and/or modify it
under the terms of the license detailed in the LICENSE file of the
Majordomo2 distribution.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the Majordomo2 LICENSE file for more
detailed information.

=cut

#^L
### Local Variables: ***
### cperl-indent-level:2 ***
### End: ***


