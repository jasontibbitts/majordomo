Various items discussed recently (2000.10.25) on mj2-dev.  Items should get
added here when it is decided that something needs to be done, and removed
when the folks who asked for the feature/fix have agreed that the feature
is in/problem is fixed, or that the feature is not needed/problem really
isn't a problem.

==================================
Implemented, awaiting verification
==================================

Better Queue Handling
---------------------

If a message causes Majordomo to crash, it remains in the queue and will
continue to cause crashes.  Thus it is a good idea to rename queue files so
they don't get rerun.  However, in the case of system crashes/random
Majordomo crashes/other nonrepeatable issues, you _do_ want the queue file
processed.  This it is advantageous to have a processing count and to only
process files some number of times normally before giving up on the file.

Also, giving up on a file is not good, as it can lead to problems not being
noticed.  Thus the idea procedure would be to process a queue file normally
twice (or thrice) and then on the next try, to turn up debugging and log to
a special file.  The next try, delete the queue file.  The owner also needs
to be informed somehow.

To manitain the generation count (and perhaps additional data we might want
to keep) mj_queuerun will maintain a status file named by prepending the
message filename with a '.'.  In it is stored a single line with a single
number: the attempt count.  No locking of the status file is necessary.

This is implemented as requested.


Duplicate Elimination
---------------------

Some code is in place to globally eliminate duplicates; when a message is
posted to multiple lists, users who are on more than one of them only get
one message if their class is set to "unique".  If the class is not unique
on all lists, the behavior is variable depending on which list gets the
message first.  If the user is in digest mode on one list and unique on the
other, they will get a separate copy and a copy in the digest.  This is not
technically difficult to change.

This is implemented.  The requesters of this feature have not commented on
whether it satisfies their requirements.


===========================
Not yet (fully) implemented
===========================


List Templates
--------------

Paul Hancock: [...] I specifically wanted something that would allow groups
of lists to be managed with a given DEFAULT file... not necessarily
domain-wide, which is now possible just by changing DEFAULT.

One proposal is to have multiple DEFAULT lists, named DEFAULT-template.
Another is to allow multiple configuration files per list.

Some of the code necessary for multiple configuration files per list is
already in CVS.  It is not certain that it will remain there, or whether
the end result will satisfy the request.  The "multiple DEFAULT list"
concept may be orthogonal to it.


Configuration Rewrite
---------------------

The current configuration process is incompatible with modern package
managers.  Defaults cannot be hardcoded into the scripts.  Only two things
can be: the path to Perl and the location of the config file.  Everything
else should be put into a separate configuration file.  This cound (should)
subsume the SITE config file currently used for defaults that aren't
hardcoded.

The config file should probably be raw Perl code so that it is as fast as
possible to load.  The Q&A section of Makefile.PL can be extracted and
turned into an "easy setup" script.

Also, the temporary directory (and probably several other variables) needs
to be made part of the site config instead of a per-domain configurable.


Wrapper Security
----------------

The wrapper needs to sanitize as much of its environment as possible.  This
involves making a list of needed env variables and deleting everything else.


Bounce Handling
---------------

Hook up bounce_rules execution when a bounce comes in.  Most of the
infrastructure is in place for this.

bounce_rules actions:

ignore - don't tell the owner and don't remove the user
inform - inform the list owner of the bounce but don't remove the user
remove - remove the bouncing user and inform the owner
  Modes for remove:
    -quiet - don't inform the owner
    -noprobe - don't send a bounce probe (currently, this is always on)
    -consult - ask the list owner before actually doing any removals (not implemented)
    -noattach - don't attach a copy of the bounce (not implemented)

Two kinds of messages:

 1) specify something to be sent to the owner
 2) specify the form of a bounce probe

Statistics are always gathered when appropriate.

bounce_rules variables:

$failure - true if bounce indicates a failure
$warning - true if bounce indicates a warning
$consecutive - count of consecutive messages bounced

$consecutive_time_span - number of days between first and last consecutive
  messages.  Use to ensure that not only is an address bouncing consecutive
  messages, but that they are bouncing them over a long enough range of
  time.  (not implemented yet)

$bouncedpct - percentage of messages bounced, determined by look at how
  many messages have bounced between the first known bounce and the last.
  Note that this is not an absolute indicator of how many messages have
  bounced, since it make take a week or more to see bounces.  This means
  that if an address bounces once, $bouncedpct is will be 100.  So, only
  use $bouncedpct in conjunction with some other measure of bounces, such
  as $month.  When used this way, $bouncedpct is quite useful in handling
  addresses that bounce some constant percentage of messages but that you
  don't want removed automatically.
$day - the number of bounces in the past 24 hours.
$week - the number of bounces in the past seven days.
$month - the number of bounces in the last thirty days.
$subscribed - true if the user is subscribed to the list
$days_since_subscribe - the number of days since the address was added to
  the list.
$numbered - the number of numbered bounces seen.
$span - the difference between the lowest and highest message bounced.

$diagnostic - the actual diagnostic; match against this to try and
  special-case certain types of bounces (not implenented)

default:

# Don't bother the owner with warnings
ignore
$warning

# Delete users after 50 consecutive bounces
remove
$consecutive > 50

# The default action is 'inform'; all bounces not matched by the above will
# cause an informative message to be sent to the owner.


Uuencode and ms-tnef in the body as "attachments"
-------------------------------------------------

Treat uuencode and ms-tnef chunks in the body as attachments so that
attachment_rules can be used to trap or remove them.

Come up with some fake MIME type used to represent these "attachments" so
that they can be put in attachment_rules.  "uuencode" and "ms-tnef" are
probably sufficient, although there is potential for confusion because a
rule of "uuencode | discard" wouldn't discard a real MIME part of type
"application/x-uuencode".

When checking for taboo lines, if the above fake mime types are referenced
in attachment_rules, scan the body for a sequence which identifies them and
trap the message accordingly.  (How to check if they're referenced?  Run
the rules code and check the result.)

When modifying the body, if the above fake mime types are marked as
"discard" in attachment_rules, scan the body for the identifying sequence
and drop the whole body part up to and including the ending sequence.
Insert a message indicating that the data was deleted.


MTA configuration hook
----------------------
Many MTAs need special programs to be called to build database files out of
the aliases and associated files which we generate.  This is not generally
possible to do within Majordomo for two reasons: 1) it is site-dependent
and 2) it requires priviliges that Majordomo doesn't have (frequently
root).

To solve this add a "hook": look for a program in a specified place and, if
it exists, call it with some defined calling convention.

For many sendmail installations, it suffices to call newaliases, although
on newer sendmails this must be done as root.  Other installations need
calls to makemap as well.

Possibilities: 1) setuid program to exec newaliases 2) touch a file, which
is checked by a root-owned cron job that runs newaliases and makemap if
it's present.

Exim can use this feature to use databases instead of flat files, which
would speed up installations with large numbers of domains or lists.

Suggested script location: $install_dir/libexec/build_databases.  Not in
  the normal bin directory, because this is not a user executable.

libexec chould be mode 700, owner majordomo, group majordomo.  (This is
  security sensitive, and should be restricted beyond normal majordomo
  files.)

Arguments taken: none; the script gets called any time a change is made and
  should generate all databases.

Permissions: 700, owned by majordomo or 750, owned by root, in majordomo
  group.


Mj::Util module
---------------
Collect utility functions into a single module.  For instance, this part of
Mj::Access is bad:

	    $args{'delay'} = Mj::List::_str_to_time($value) || $time + 1;

_str_to_time should be named str_to_time and moved to Util.pm.  The sane
for _parse_table, (perhaps) parse_keyed, compile_pattern, (perhaps) _compile_rule,
_str_to_offset, _str_to_clock from Config.pm, etc.

A full list:

List::_str_to_time
List::_str_to_time_dm
List::_time_to_str
Config::compile_pattern
Config::_str_to_offset
Config::_str_to_clock
common rule-running code from BounceHandler::handle_bounce_user and
  Access::access_check (already started)

These must be functions, not methods.  Methods should of course go in their
class.


mj_queuerun lifetime limiting
-----------------------------
In addition to an idle timeout, mj_queuerun needs a limit on how many
messages it will process without exiting.  This keeps memory leaks under
control.  The queue server will simply start another runner when one exits,
so this is a safe cleanup mechanism.


mj_queueserv bug with all dead queue runners
--------------------------------------------
mj_queueserv has a bug where it will queue the message due to excessive
load when in reality every single queue runner has died.  This happens
because it runs through all of the slots looking for a live and unbusy
runner, cleaning up dead ones along the way.  But it needs to restart the
search if it's cleaned up any dead ones but has run out of slots without
finding any waiting runners.
