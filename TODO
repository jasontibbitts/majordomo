-*- Text -*-

Plan
----

Finish what is required to run my lists:
  archives

Test the hell out of it.

Switch over one of my lists.  (How?  Manually maintain subscription
  list?  Put Mj2 at the normal address and forward requests to other
  lists to the old server?  (Hmmm.)

Top of the list 
---------------

!! Warnings from inform (2, at line 70, 1 at line 86) after chained
   consultation?
   $req is undef, 

!! Fix expiry time in consultation tokens.  Uses computed seconds value for
  expiration instead of the number of days.

! Test forwarding mechanism.

! Set up shadow list to funnel all of my list traffic through.

! Make sure all sent mails have To: headers.

! Auto-configure global defaults instead of relying on defaults file, so
  that we can minimize config file access time (because defaults must be
  parsed).

! Message size limits
  Header line length limits
  Quoted text limits

- Implement rejection (and perhaps acceptance) messages for tokens, and add
  a box to type them in to the web interface.

- Rewrite the web interface to use proper design techniques.

! Code to force 2047-encoding of headers.  Function should take an entity
  and a charset and call MIME::Words::encode_mimewords on each header.
  What will e_mw do with embedded newlines?  If the charset is not provided
  (undef), the routine should try to figure one out from the charset of the
  body, or if one can't be figured out, it should use ISO-8859-1.

! Implement separate user-readable and owner-readable bounce reasons.

! Resend: Get rid of specific message checks and instead have four basic
   functions:
     header checks
     non-multipart body checks
     part tree traversal
     multipart body checks

   The idea is to recurse the part tree and read through each body
   part only once.  Right now the checksum routines do it, the taboo
   routines do it and the mime checking routines do it, all
   separately.  (It might be possible to also do the approval trimming
   in with this, too, but it would be more difficult.)

! Format: finish rewriting the following
    filesync
    configshow
    configset
    configdef

- rewrite lots of routines to take named arguments instead of positionals.

- Allow end user to set language preference.  Add language choice as extra
  parser variable.  Export a core set_language routine.  Reference a
  Majordomo class variable inside of internationalization routines.

- Turn Addr.pm globals into global configuration options.
  Make an address validator object; allocate it at Majordomo startup and
  pull the appropriate config variables into the new Mj::Addr call.

- Resend:
    Front-end filtering stuff - 
      header improprieties (not in To or CC header, etc.)

   Back end mime-modification functions come later.


- Add some variable expansions in message_fronters/footers like in
  message_headers. 

! Simple mail forwarder:
   A precursor to real bounce handling, a routine that received mail at
   owner-list and distributes it to one or many owners.  Should be easy.

  Write bounce_start, bounce_chunk, bounce_done which accept a bounce and
    figure out what to do with it.

! Write up truncation logic to keep envelope sizes down for bounce probes.

- Access:
    Document it better.

    Interfaces should make an access_check for "connect".  Here we can
    wedge in neat things like free disk space checks.  This should be
    independent of the call to "access", because by that time we've
    already done message parsing.  The idea is that before we do
    anything that could consume disk space or CPU, we make sure that
    we have enough disk space or CPU.  

    Decide on a scheme to delay/consult/deny frequent or repeated
    requests with output sent to a specific address.  Dig out my
    conversations with Chuq on this issue.

    Default action for 'post':
      fail if moderated.
      check restrict_post; if entry has same name as list, look in
        that file else look in the given sublist if it exists.
      check all of the taboo_* admin_* dup_* and *_mime variables and
        do the appropriate thing.

! umask setting in interfaces? or in core?

! Clean up all Majordomo-level commands.  Add
  access checking and split across the token barrier properly.

  auxwho
  auxremove
  unalias
  which
  get
  put

- Make sure generated command lines properly include arguments.  When
  processing here args, the command line should properly include the
  arg.  (This is a TextOutput issue; in the loop reading from the
  arglist, need to make sure that the current argument is placed
  somewhere on the $cmdline that the core function is called with.

- inform and consult uses moderators variable, listing named groups of
  moderators:

  namea
  addra1
  addra2

  nameb
  addrb1
  addrb2


- list owner information (on hold until I collect more logs to process)
    A 'report' command used to give several list metrics:
      summary of activity (from inform_owner routine)
      message statistics generated from the archive index (from Dave's
        stats code)
      symmary of existing tokens
    
   Two reports:
      list report: summary of activity for one list.  Includes detailed
        breakdowns on who did what to whom.  Categorize all subscriptions,
        all unsubscriptions, and indeed all activity broken down per
        request type.  Summarize activity at beginning of report.  Include
        posting activity at a later date, since this is logged separately.
        (Should this be logged separately?)
        Shows all open, non-permanent tokens for the list.

      GLOBAL report: report on all things global.  Give a breakdown on all
        GLOBAL commands and tokens.  No postings here.  Also give summary
        of all requests broken down by list.

   Command takes zero, one or two dates.  No dates makes a report since the
     last no-date report.  One date makes a report from that date forward.
     Two dates makes a report between the two dates.
     
   Modes can be used to specify only tokens, only actions or only traffic
     (or notokens, notraffic, noactions) and only failed, only stalls, only
     success, only passworded, etc.

-  Get rid of the rekey function altogether and trigger a change of
    the addr_xforms variables (or anything else that would require a rekey)
    to do it automatically.
   Add some intelligence to the rekey routine, to check for collisions.


Well thought out stuff:
----------------------

- Internationalization.  File search list is already done.  Have the core
  provide internationmalization functions.  Place, in the normal filespace,
  a file containing translations for messages too short to warrant their
  own files.  Use the current file search list to locate this file, then
  read it into a per-list data structure.  The file's format should look
  something like this:

  # Comments
  language
  message_tag
  Translation $A of $C tag $B!

  another_message_tag
  Translation Line 1
  $A $B $B line 2

  [...]

  The data structure looks like this:

  $self->{trans}{$lang} =
    {
      message_tag => 'Translation string',
      [...]
    };

  Variables to be replaced in the string are of the form $A, $B, etc.

  Translstion involves looking up the message tag, making the substitution
  with the given variables and returning the string.

  If the necessary translation tag does not exist, what to do?  Back off to
  the global entry under the same language, then to English, and then to
  some default string?  Or try to "fill in the blanks" (parse another file,
  pulling in only those language tags not in the data structure) from the
  next thing in the search list?

  Right now, back off to global makes the most sense.

  The data structure can also hold a timestamp; the search path is
  consulted to find the first matching file which is then statted and
  compared; if it has changed (at all, perhaps only due to a changed search
  list finding an older file), it is reparsed.

  The stored translation data structure are stored (via Date::Dumper) in
  _trans in the list's root.

  The default English translations can be placed in the code and used on
  the client side.

- Daemon model.  Startup time is always going to plague us.  The solution
  is to eliminate it.  Have daemons run in the background as necessary to
  serve requests.

  In the temp directory, have one directory per domain.  In that directory,
  have a file containing the number of simultaneous daemons allowed.  The
  client can look for daemons by Unix domain sockets there.  It should
  select on all available and if it times out (or there aren't any to begin
  with) it should spawn them.  It will never spawn more than the maximum.

  A daemon just select on its socket until it hits a connection, then it
  accepts and talks client-server over the socket to do things.  If the
  select times out, the daemon can exit, taking its socket with it.  This
  limits the number of daemons to what is needed.

  The clients should be small, so that they compile quickly.

  Client looks like normal; everything is in the Majordomo module.  A
  global can be consulted to do C/S or monolithic; the Majordomo module can
  itself use Mj::Client or Mj::Core.

  Daemon just calks Mj::Protocol, calls routines on its $mj and passes the
  results back to Mj::Protocol.

  A Mj::Protocol module can implement the C/S protocol, which should look
  sort of like SMTP.  A transaction (from the view of the client) looks like:

  >> CONN
  << 30 OK; need: data, interface
  >> ARG data
  << 31 OK, send
  >> +Connection data line w
  >> +Line 1
  >> +Whatever
  >>
  << 31 Received arg data; still need interface
  >> ARG interface
  
  << 20 Connection received; ID follows
  << 21
  << 22-1234132BCDAF23432ED245AB
  << 22
  << 23 End of return values
  >> UTIL get_all_lists
  << 30 Command received; need user, pass, interface

  Client sends two-letter mnemonic strings, many having (optional)
  arguments.  Server sends numeric result codes.  (This is asymmetrical
  because server needs to be chatty and thus needs a way to communicate
  return values.)

  Call sequence:  DISP/UTIL, ARG (name), ..., ARG (name), ..., END
   Server will not execute any routines until END is seen.
  Return sequence: 20, 21 (name), 22..., 21 (name), 22..., 23
   Client should read continuously until 23 is seen.

  20: printed after all arguments received, contains status message.
  21: return value follows, gives name
  22: return value
  23: end of return values

  30: got yor command, want some arguments
  31: Send the argument
  32: got the argument
  33: got all arguments you sent.

  (codes beginning with 1 reserved as in SMTP; could be used to provoke an
  answer from the UI.)

  START:    connection, takes optional session key
  COMMAND:  call the dispatcher on the given core function name
  UTILITY:  call the named utility function
  QUIT:     close the connection
  DIE:      have the daemon exit
  ARGUMENT: named (or unnamed) argument follows
  LINE:     here comes a line of data
  END:      all arguments sent

  (only the first two characters are significant)

  A "+" endicates an appended newline that should be preserved.  A '-'
  indicates a value with no newline.  A blank is the universal "end of
  transaction indicator".  A line with a blank is assumed to be _not_
  newline terminated, so most return values can be printed in one line.  An
  empty line (containing just a newline) is just '+', a completely empty
  string is just '-'.  (In other words, to print newline-terminated
  strings, chomp, then print "+$string" for each line.)  This is much like
  SMTP, in that you can parse until the first character after the code is a
  space.  A return code with nothing following it is required to terminate
  a newline-terminated string.

  Arguments are communicated to the server with ARG commands; these
  optionally take a name for named args.  Args are transmitted one at a
  time until all are sent.  There is no fixed limit on the number of
  arguments.

  This enables names arguments to be sent as easily as passing a hash.
  This means that lots of things can be rewritten in a much simpler manner
  now.  Drat.

  The utility/dispatch difference serves to reinforce the distinction
  between these types of functions; dispatch functions all take the same
  arguments.

- mj_resend should go through the dispatcher and use the iterative
  interface instead of the direct post function.
    
- Archiver:
    Retrieve message given archive name and number
    Retrieve last N messages/message numbers from archive
    Build index from existing file (sync)
    Delete message from archive?
    Automatically add meaningful description to created archive files.

- Digest:
    Trigger parameters:
      maximum size
      maximum messages
      minimum size
      minimum messages
      max age of 1st message
      min age of last message
      time(s)
      runone, runall

if ($age1st > $maxage) {
  trigger;
}
else {
  if ($size >= $minsize || $msg >= $minmsg) {
    if ($agelast > $minage) {
      if (time > $triggertime && $nottriggeredrecently) {
        trigger;
      }
    }
  }
}

persistent digest_info:
 @messages
 $volume
 $issue
 $last_triggered
 $last_triggered_clock

saved via Data::Dumper.

- Digestifier:
    Add message number to digest
    Trigger - ?
    Build digest given message numbers.

- bounce handling
    Parse all mail to owner alias, looking for bounces.
    Do periodic single-address-probes.
    When bouncing address detected, put on bounce status.
    Send bounce probe daily(?) with token that changes status back to
     active.
    Remove from list after N days.

    Use sequence numbers in envelopes to determine when to put an address
    on the bounce list: after N consecutive bounced messages (N
    configurable, of course; low-traffic lists will want to remove after
    one bounce?

    Make additional piece of subscriber data indicating that an address
    should be explicitly bounce probed (perhaps if the address was found to
    be bouncing from a bounce parse or if an explicit bounce probe came
    back).  The idea is to make sure that we continue to probe a bouncing
    message until it no longer bounces or until we see enough true bounces
    to remove the address.  We don't want to remove for intermittent
    failures, because the user will complain about having to return himself
    from bounce status often.

    We already have a bounce field in the subscriber database; use it to
    store message numbers that bounce or a generic "found a bounce" tag,
    along with timestamps.  If this field is non-null, always probe the
    address.  The bounce handler can look at this field and determine what
    to do when it gets a bounce based upon the history there.

    Periodic trigger can remove old bounce data after so many days.

- uniquify function names
    Make function names unique to 8 characters, to appease AutoSplit.

- Verify that non-wrapper configuration is correct
      create a dummy script, make it setuid, and run it.  If it errors, we
      know it's bad.

- store some data on each user-request so we can limit abusers.  Basically
  we want to store enough data to see if an address is sending too many
  requests to us.  a circular list of a fixed size would probably be good;
  we save it between sessions and if an address shows up too many times we
  set an access flag before running the access check.
    One big global queue?
    One queue per request?
    One queue per list?
    One queue per list per request?
    Something else?  Some kind of time average per address per request?
  How do we allow things like someone who works offline and dumps a pile of
   email every couple of days?
  How do we back off when a user gets close to the limit?  We don't want to
   just start ignoring requests.  We could sleep, then sleep some more,
   then bounce, then reject, then ignore progressively as the traffic
   increases.
  How to make sure that a slow server that has only a few users doesn't
   fill up a queue with only a few addresses causing them to bounce?  Store
   address and a timestamp and ignore/purge old requests?
  How to store this data?  Probably not in the config file.


Categorized ideas:
-----------------

Config Stuff
- list default_flags, default_class
- Variables for default_class, default_digest, all of the various digest
  modes, all of the default flag settings.
- passwords <<  asdf : !config
- proper checking of non-optional args in table-parse

Email Interface
- prescan for bad situations: unmatched tokens, too many subscribes in one
  message, etc.
- prescan for access restriction override.
- context-sensitive help: TextOutput routines return list of help topics
  with error; email interface looks up topics and mails back appropriate
  help.
- make sure that no internal routine gets called with an undefined list:
  "subscribe" sent with no deflist set.

Majordomo.pm
- resubscribe (change address)

TextOutput
- rekey ALL or GLOBAL
- info ALL for hyper-long lists output
- auxshow list ALL
- aux lists for GLOBAL?
- alias ALL.

Finish access restriction mechanism 
- need better syntax checking
- mondo documentation

Confirmation/Approval engine
- Ability to append or prepend information to approved messages
- list tokens, expire old tokens.

Resend
- MIME transformations
- Address exclusion on CC or nocopy.

Mj::Log
- Log classes; too much debug info now
- Have aborts and warnings stuffed into some tempfile and process that file
  after the fact.  This allows aborts to propogate even if we've hosed the
  mail delivery system.

Aliasing
- Should aliases be global only?
  To do this, we need a global database of all addresses with aliases
  and all of the lists they belong to.  Maybe we need a global
  database of all addresses on any lists.  This may be a bad thing.
  Perhaps we could get away with complete list membership checking for
  alias ops, but that looks like a bad thing.  Global actions that
  potentially affect all lists are not good; they probably shouldn't
  be triggerable by anyone on the net.

  After more thought, it seems that checking list memberships for every
  alias call isn't that bad an idea; alias calls probably won't be that
  common and we to it anyway for extended lists output.  We have to check
  that the destination is subscribed to at least one list, and that the
  source is not subscribed to any lists.  The unalias call just needs to
  remove the alias if it exists, and shouldn't require any additional
  checking.

Aux address lists
???

Meta
- Add proper $VERSION tags for all modules.
- Figure out the proper names for functions and clean them all up.
- Figure out how do make all messages configurable.
- Make sure that addresses are validated/stripped as little as possible.
  If a routine can return an error string and needs to strip the address,
  it can save upstream functions the trouble.
- Try to avoid aborting when there is another way.  Unfortunately, aborting
  happens at the lowest levels of the code (that would have to be working
  anyway in order to send abort messages).
- Try to decide at just which level should the address be validated.
- Make stub modules that inherit from the real modules so people have a
  place to put their extension/overriding code without copying things
  around.

List
- Make sure that tabs don't leak in from the interfaces.
- Cache is_subscriber data, since some operations may check this more than
  once per run.  (lists=enhanced with some advertise settings, e.g.)
- Cache flag data, since flags can get set in chunks.  Alternately,
  make flag_set take a list of flags.

SimpleDB
- Keep list in sorted order to speed up searches (use seek and binary
  search?) and pull out rows in sorted order (for domain-based grouping in
  the delivery engine).  Or just recode the thing to use BTrees.
- Clean up lookup methods; they're a mess.  Collapse duplicated code.
- Code to sort list given a coderef to a compare function.

GTK client
telnet client
web client - Bill
Finish all commands
Figure out client-server spec.


Uncategorized random thinkos:
----------------------------

retrieve and replace individual subscriber field data, for hard-core admin
 stuff.
Subscription policy patch -> sponsored subscribes.
Waiting period for new subscribers?
Partial digests when converting to single message receipt.
archive search engine?
Integrate Dave's logmail stuff -> stats command.
Support for multipart/alternative when sending welcome messages.
Periodically sort lists for proper batching.
Spellcheck the documentation and messages.
PGP verification for email.  How to trust a client?
Internally equate meta-lists * and ALL (valid_list)
Limit message delivery/email request processing to certain times/load
  averages
Some way to store some data until the next time a user communicates with
  us.  So if, say, they are unsubscribed due to bounces but later try to
  send a message or check their subscription status they will be informed.
  Obviously we can't inform them when remove them, since that message would
  bounce, too.
Make access_check for "access" return some sort of session key, so that it
  can be passed in $auth?
Objectify the parser, then register legal methods with it?
Bounce handling:  hack on BounceFilter and AutoBounce.
Simple patterns: just '*' as "match any"; set "simple_patterns" variable,
  and if set do $var =~ s/\*/\001/g; $var = qm($var); $var =~ s/\001/.*/g;
  on every list config read that doesn't default when type =~ /regexp/.
Novice_level variable that affects getting documentation for config
  variables?  Novice set of config variables?  Novice config documentation?
Extra access variables for post method; any_admin, any_taboo, any_dup, etc.
Header length and body length limits.  (body is easy; compute content-length).
digestvolume command to increment (default) or set the volume number for a
  digest.
Expiration of subscriptions.
Last posting date.
Resend sequence numbers: keep a state file per list with the current
  sequence.  Allow setting of the sequence number.
Separate directory for lock files, or locking that doesn't need them.
Have who expand lists subscribed to current list.
Clean up the flag and class setting code.
Access_rules methods for checking against requesting user instead of victim.
Forward to other (or same) server, but change the list name.
-c option to mj_email (or new mj_command script) to always execute a
  command when a mail is received.
Tokens with infinite lifetime bound to addresses; use this for a permanent
  unsubscribe token that works if addresses change or whatever.  Scan
  occasionally for bound tokens and eliminate them if the address is no
  longer subscribed.
Switch $mode and $cmdline in public Majordomo functions.
Have 'help command xxx' look up config comment string for xxx.
Support X-No-Archive.  _post should look for headers and pseudo-headers,
  but not remove pseudos if found.
Createlist should mail information to the list owner.  This should be
  some distilled version of list-owner-info, containing pointers to
  additional documents that can be retrieved with the help command.
  Of course, all of these documents need to be written.
Add Majordomo version info to the X-Mailer header that MIME-Tools adds.
Make a separate repository for the backup default files so that we can
 upload them without worrying about overwriting local modifications.
Handle stupid crap like "subscribe to list" and "subscribe list digest".
Some kind of pseudo-anonymizer so that users' addresses are replaced by
 some anonymous token; when the message hits the archives, the headers are
 replaced by this.  This prevents harvesting of addresses from the
 archives.  Majordomo can handle the mapping between tokens and addresses.
Allow a 'default prefix' command to specify a prefix to strip from all
 lines in the text parser.  This allows replies to be yanked and quoted, as
 long as they aren't line wrapped.
Allow 'approve password' on the line before the command to be approved.
New 'append' mode to configset to append additional data from a variable
 instead of replacing the existing data.
Add additional sender information to things like confirmations so that if
 they bounce, the bounce processor can take care of the generated token and
 not forward the bounce to the owner.
Allow referencing sublists of other lists in access_rules.
Digests with detached bodies; send just a table of contents and let the
 client retrieve the messages they want.
