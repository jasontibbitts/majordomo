-*- Text -*-

Plan
----

Do master database conversion.

Test the hell out of it.

Switch over one of my lists.  (How?  Manually maintain subscription
  list?  Put Mj2 at the normal address and forward requests to other
  lists to the old server?  (Hmmm.)

Cut alpha 2.


Bugs?
-----

Messages with empty first part always checksum the same?
The interface can pass in bad lists and nothing checks them.  Explosions
  result.
The interface can pass bad passwords to some functions (config_get_vars)
  and get a result indistinguishable from using no password. 
Untainting sometimes happens in the wrong place; in a C/S model, we won't
  trust what comes in over the network.

Top of the list 
---------------

Access: call Mj::is_subscriber instead of List::is_subscriber.

Pass stripped address to access restriction language: $svictim =
$victim->strip; share $svictim (local); pass to reval.

Fix parse_taboo_body and parse_taboo_header to call parse_regexp so the
cool parsing effects everything.

Fix comands that take regexps to call Config::parse_regexp to get back a
Perl regexp to use.
  which

Invalid addresses and never compare equal to anything else.

! Auto-maintain aliases:
  Add 'del_one' in Mj::MTAConfig::Sendmail; opensa filerepl and copies the
  alias file until the opening comment is hit, then it skips until after the
  closing comment, then prints the rest of the file.  Use this for a
  'createlist-delete' routine.

! Archiver:
    Build index from existing file (sync)
    Delete message from archive?
    Automatically add meaningful description to created archive files.

    Search the archive
    Get an index of the archive.
    How to specify the time period here?  Two dates?  Leave one and it goes
     from then to now.

! Digest:

Switch around parameters order in digests variable.
Allow a time of 'any'.
report-digest command to show status of digest spools.

  Configurables:
    subject
    index header
    index line
    index footer
    digest footer - after all messages

Way to force the users to use the digest version:
  allowed_subscribtion_classes - array of names of subscription classes that
  users can join without owner's password approval.  'digest' covers all
  digests, 'digest-blah' allows only 'blah' digest.

List::digest_trigger - just call trigger method, pass results to digest_generate.

List::digest_add - add num.data pair to digest (call $self->{digest}->add).
  If results, call digest_generate

List::digest_generate - actually make all of the digests and stuff them in
  files.  Wrap the filenames up with the classes to be delivered to somehow
  (key by digest name, perhaps) and return them.  Mj::Resend can deliver
  them.

  Take the built entities
  and stuff them into files.  Return a list of digest, file pairs.
  Resend::_post can take those and deliver them to the appropriate classes:
    digest-digestname-digesttype: digest-daily-mime, digest-weekly-html

Optimize digest sending: when a digest is made, the digests will always be
sent to more then one class.  Therefore it is a waste to scan the list
twice.  What we want to do is extract matching addresses according to
class, then stuff them into the appropriate delivery buckets.

To do this, change the args to Mj::Deliver::deliver to take per-class
args.  Then build a proper selection function, extract out all matching
entries, and put them in the various delivery buckets all at once.

Decide on digest classes: class - "digest", classarg1 - digest name,
classarg2 - digest type?

- add nonterminal access_rules.  Now we take the first matching, but we
  could act and keep going.  This could be used to add reasons to a list,
  falling through to a final consult or deny.  Would require restructuring
  the compiled code to push into a list instead of returning on first
  match.

  add unset action to erase a variable (to, say, ignore taboo matches for a
  class of users)

  add reason action to stuff another bounce reason onto the list.


! Utility method to set the default language from the interface.
  Check the user's chosen language.  Should the language used be that of
  the victim or the requester?  The requester will see the immediate
  output, while the victim will receive instructions.  Or look up the
  language preference of the user when sending out end-user information.

- Extension mechanism:  one file, in $::TOPDIR/$domain, called
  local_extensions.pl.  Pulled in after all properties are defined and
   mj_cf_data is loaded (so the two important hashes have been defined).

  Provide methods to call in local_extensions.pl:

  add_feature: adds a feature to the feature list (to advertise the
  extension if necessary)

  add_command: adds a command to the big function structure.  Takes lots of
  data to be filled in.

  add_alias: adds an alias for a command (localization, I suppose).

  add_variable: pushes a variable into the big config hash.

  Adding a function: need four functions:
    arg marshaller
    output formatter
    top half (if not generic)
    bottom half
  These have to go in the proper packages.  Rely on the writer to get this right?

- Add generic top half functionality, now that the dispatcher does so much.
 Would eliminate top halves for:
   alias (with additional parameter for validating additional positional
     arguments as addresses.
   auxadd
   auxremove
   auxwho_start
   register
   rekey
   set
   show
   showtokens
   unalias
  Add to dispatcher:
   exactly which positional arguments to validate as addresses.
   generic_top_half item
  Write generic_top_half function:
    Log in; display some args
    Make list if necessary.
    Call access check.
    Log result.
    Call bottom half if necessary.

! One more majordomo routines to work over for the rewrite:
  rekey - this needs to be a generic database-lint routine.  The keys
   should be regenerated from the stripped addresses and the list of lists
   in the reg database should be updated from the actual membership lists.
   This makes this a global function and an extremely time consuming one.

! Dispatch should log password failures for overriding logging.

- Make 'default' work in interactive shell.

! Investigate other locking methods.

! Make sure that $SENDER is reset properly after _trim_approval is called,
  so we pick up the real sender, not the approver.

! Make sure all sent mails have To: headers.

! Continue generalization of database mechanism.
  
  Write generic export and import functions.

  Write autoconversion function.

  Write backends: BerkeleyDB, MySQL.

- Need a deletelist command.  Should update the master address database,
  removing all of the entries.

! Finish archive interface.

! Make sure that archives get a separate umask, so that people can
  download them.

- Add Makefile.PL section to look for features in addition to
  prerequisites; if the necessary modules are present, the features will be
  enabled.

  Features: Time::HiRes
            DB_File (or BerkeleyDB?)
            whatever the MySQL module is

- Tool to incorporate mbox files into an archive.
  Can run from alias (like archive2.pl) or can slurp an entire folder.
  Can take a list (in which case it sucks things from the list's config) or
    the necessary variables (dir, split, size) directly.

  Import from files:
   mj_archive -d domain -l list file1 file2

  In an alias (read 1 message from stdin):
   mj_archive -d domain -l list

  Without a list, import from files:
   mj_archive -r directory -p split -z size file1 file2

  Without a list, import from stdin:
   mj_archive -r directory -p split -z size

! Split up _post a bit.  Remove reply-to and subject_prefix handling to
  separate functions.

! Make mail_message go through the same delivery functions as normal
  delivery.

! Add a banned_domains list; just ignore connections from these hosts.

- Implement rejection (and perhaps acceptance) messages for tokens, and add
  a box to type them in to the web interface.

- Rewrite the web interface to use proper design techniques.

? Move spool files out of filespace like sessions?  Use filespace only for
  things needing remote access (not spooled files) or things needing i18n
  (not spooled files) or things you want an index of (perhaps spooled
  files).  Maybe an open token report is warranted.

! Code to force 2047-encoding of headers.  Function should take an entity
  and a charset and call MIME::Words::encode_mimewords on each header.
  What will e_mw do with embedded newlines?  If the charset is not provided
  (undef), the routine should try to figure one out from the charset of the
  body, or if one can't be figured out, it should use ISO-8859-1.

! Implement separate user-readable and owner-readable bounce reasons.

! Format: finish rewriting the following
    filesync
    configshow
    configdef

- allow mime-match classes just like taboo classes.

- rewrite lots of routines to take named arguments instead of positionals.

- Allow end user to set language preference.  Add language choice as extra
  parser variable.  Export a core set_language routine.  Reference a
  Majordomo class variable inside of internationalization routines.

- Turn Addr.pm globals into global configuration options.
  Make an address validator object; allocate it at Majordomo startup and
  pull the appropriate config variables into the new Mj::Addr call.

- Resend:
    Front-end filtering stuff - 
      header improprieties (not in To or CC header, etc.)

   Back end mime-modification functions come later.

- Auto-configure global defaults instead of relying on defaults file, so
  that we can minimize config file access time (because defaults must be
  parsed).

- Add some variable expansions in message_fronters/footers like in
  message_headers. 

! Simple mail forwarder:
   A precursor to real bounce handling, a routine that received mail at
   owner-list and distributes it to one or many owners.  Should be easy.

  Write bounce_start, bounce_chunk, bounce_done which accept a bounce and
    figure out what to do with it.

! Write up truncation logic to keep envelope sizes down for bounce probes.

- Access:
    Document it better.

    Interfaces should make an access_check for "connect".  Here we can
    wedge in neat things like free disk space checks.  This should be
    independent of the call to "access", because by that time we've
    already done message parsing.  The idea is that before we do
    anything that could consume disk space or CPU, we make sure that
    we have enough disk space or CPU.  

    Decide on a scheme to delay/consult/deny frequent or repeated
    requests with output sent to a specific address.  Dig out my
    conversations with Chuq on this issue.

    Default action for 'post':
      fail if moderated.
      check restrict_post; if entry has same name as list, look in
        that file else look in the given sublist if it exists.
      check all of the taboo_* admin_* dup_* and *_mime variables and
        do the appropriate thing.

! Clean up all Majordomo-level commands.  Add
  access checking and split across the token barrier properly.

  auxwho
  auxremove
  unalias
  which
  get
  put

- Make sure generated command lines properly include arguments.  When
  processing here args, the command line should properly include the
  arg.  (This is a TextOutput issue; in the loop reading from the
  arglist, need to make sure that the current argument is placed
  somewhere on the $cmdline that the core function is called with.

- inform and consult uses moderators variable, listing named groups of
  moderators:

  namea
  addra1
  addra2

  nameb
  addrb1
  addrb2


- list owner information (on hold until I collect more logs to process)
    A 'report' command used to give several list metrics:
      summary of activity (from inform_owner routine)
      message statistics generated from the archive index (from Dave's
        stats code)
      symmary of existing tokens
    
   Two reports:
      list report: summary of activity for one list.  Includes detailed
        breakdowns on who did what to whom.  Categorize all subscriptions,
        all unsubscriptions, and indeed all activity broken down per
        request type.  Summarize activity at beginning of report.  Include
        posting activity at a later date, since this is logged separately.
        (Should this be logged separately?)
        Shows all open, non-permanent tokens for the list.

      GLOBAL report: report on all things global.  Give a breakdown on all
        GLOBAL commands and tokens.  No postings here.  Also give summary
        of all requests broken down by list.

   Command takes zero, one or two dates.  No dates makes a report since the
     last no-date report.  One date makes a report from that date forward.
     Two dates makes a report between the two dates.
     
   Modes can be used to specify only tokens, only actions or only traffic
     (or notokens, notraffic, noactions) and only failed, only stalls, only
     success, only passworded, etc.

- subscriber flag "novice/expert" passed in as a parameter to "post" access
    control.

- Rewrite shell.t to just build the file, call mj_shell once (or perhaps
  just a few times) and check the output.  This should improve test times
  quite a bit.

- RBL queries:
  parse all Received: headers, look for IP addresses.
  Look them up in the RBL..
  Add an exemption list (addrs?  IPs?)
  Set access variable; bounce to owner by default if set.
  Don't ever do any checks if some config variable not set.


Well thought out stuff:
----------------------

- Internationalization.  File search list is already done.  Have the core
  provide internationmalization functions.  Place, in the normal filespace,
  a file containing translations for messages too short to warrant their
  own files.  Use the current file search list to locate this file, then
  read it into a per-list data structure.  The file's format should look
  something like this:

  # Comments
  language
  message_tag
  Translation $A of $C tag $B!

  another_message_tag
  Translation Line 1
  $A $B $B line 2

  [...]

  The data structure looks like this:

  $self->{trans}{$lang} =
    {
      message_tag => 'Translation string',
      [...]
    };

  Variables to be replaced in the string are of the form $A, $B, etc.

  Translstion involves looking up the message tag, making the substitution
  with the given variables and returning the string.

  If the necessary translation tag does not exist, what to do?  Back off to
  the global entry under the same language, then to English, and then to
  some default string?  Or try to "fill in the blanks" (parse another file,
  pulling in only those language tags not in the data structure) from the
  next thing in the search list?

  Right now, back off to global makes the most sense.

  The data structure can also hold a timestamp; the search path is
  consulted to find the first matching file which is then statted and
  compared; if it has changed (at all, perhaps only due to a changed search
  list finding an older file), it is reparsed.

  The stored translation data structure are stored (via Date::Dumper) in
  _trans in the list's root.

  The default English translations can be placed in the code and used on
  the client side.

From a message to mj-translators:

What remains is the language preference stuff (the file retrieval mechanism
can deal with a preferred language but nothing ever passes it one) and a
method for dealing with the short responses.

Short responses are the one or two line messages scattered throughout the
code.  The way to handle it will be to have an internal three-level hash
keyed on language, list and 'message tag' which will be loaded
(incrementally, as languages are needed) from message files.  Those files
will be retrieved like any response file, which allows global defaults and
per-list customization even by remote list owners.

The messages in the code will need to be identified and replaced with
'message tags' concatenated with data; the interface code can take the tags
and data, look things up in the message hash, expand embedded variables in
the returned strings and present the result (prettied and wrapped,
probably) to the user.

In other words, if in the code you see:

return (0, "User $user is a bozo because $list is not a valid list!\n");

and turn it into:

return (0, "user_is_bozo_bad_list\t$user\t$list");

The interface (really the code in Format.pm, which runs on the interface
side) looks up user_is_bozo_bad_list and gets:

User $A is a bozo because $B is not a valid list!\n
or
Yuusano $A ga bakadakara $B ga iyano risuto desu!\n

$A and $B are replaced by the values attached to the tag, resulting in the
original string (or a really bad but mildly polite Japanese translation of
it).

At least, that's the plan.

Ramp up to translation slowly:

    'translate' core call.
    One multilevel hash, static, in a require'd file:

    %trans = (
      'english' =>
        {
         'tag' => "Subst string",
        }
    )

Expand to hardcoded translations of other languages, fall back to English,
fall back to just printing the returned string (so if no messages are
changed, you always get English).

Interface needs to be able to tell the core what the user is or otherwise
figure out what the user's language preference is _if_ one is not passed to
the interface somehow (prefer-language: header, 'default language' command,
etc.)  This gets pulled out of the registration database, which allows us
to not need a list object to get a language preference, which greatly
simplifies things.

Then the 'translate' call just takes a language parameter and do the proper
lookup.

_Then_ extend things to weird per-list loading _only if_ someone decided
they want it.

We already support translated long documents.


- Daemon model.  Startup time is always going to plague us.  The solution
  is to eliminate it.  Have daemons run in the background as necessary to
  serve requests.

  In the temp directory, have one directory per domain.  In that directory,
  have a file containing the number of simultaneous daemons allowed.  The
  client can look for daemons by Unix domain sockets there.  It should
  select on all available and if it times out (or there aren't any to begin
  with) it should spawn them.  It will never spawn more than the maximum.

  A daemon just select on its socket until it hits a connection, then it
  accepts and talks client-server over the socket to do things.  If the
  select times out, the daemon can exit, taking its socket with it.  This
  limits the number of daemons to what is needed.

  The clients should be small, so that they compile quickly.

  Client looks like normal; everything is in the Majordomo module.  A
  global can be consulted to do C/S or monolithic; the Majordomo module can
  itself use Mj::Client or Mj::Core.

  Daemon just calks Mj::Protocol, calls routines on its $mj and passes the
  results back to Mj::Protocol.

  A Mj::Protocol module can implement the C/S protocol, which should look
  sort of like SMTP.  A transaction (from the view of the client) looks like:

  >> CONN
  << 30 OK; need: data, interface
  >> ARG data
  << 31 OK, send
  >> +Connection data line w
  >> +Line 1
  >> +Whatever
  >>
  << 31 Received arg data; still need interface
  >> ARG interface
  
  << 20 Connection received; ID follows
  << 21
  << 22-1234132BCDAF23432ED245AB
  << 22
  << 23 End of return values
  >> UTIL get_all_lists
  << 30 Command received; need user, pass, interface

  Client sends two-letter mnemonic strings, many having (optional)
  arguments.  Server sends numeric result codes.  (This is asymmetrical
  because server needs to be chatty and thus needs a way to communicate
  return values.)

  Call sequence:  DISP/UTIL, ARG (name), ..., ARG (name), ..., END
   Server will not execute any routines until END is seen.
  Return sequence: 20, 21 (name), 22..., 21 (name), 22..., 23
   Client should read continuously until 23 is seen.

  20: printed after all arguments received, contains status message.
  21: return value follows, gives name
  22: return value
  23: end of return values

  30: got yor command, want some arguments
  31: Send the argument
  32: got the argument
  33: got all arguments you sent.

  (codes beginning with 1 reserved as in SMTP; could be used to provoke an
  answer from the UI.)

  START:    connection, takes optional session key
  COMMAND:  call the dispatcher on the given core function name
  UTILITY:  call the named utility function
  QUIT:     close the connection
  DIE:      have the daemon exit
  ARGUMENT: named (or unnamed) argument follows
  LINE:     here comes a line of data
  END:      all arguments sent

  (only the first two characters are significant)

  A "+" endicates an appended newline that should be preserved.  A '-'
  indicates a value with no newline.  A blank is the universal "end of
  transaction indicator".  A line with a blank is assumed to be _not_
  newline terminated, so most return values can be printed in one line.  An
  empty line (containing just a newline) is just '+', a completely empty
  string is just '-'.  (In other words, to print newline-terminated
  strings, chomp, then print "+$string" for each line.)  This is much like
  SMTP, in that you can parse until the first character after the code is a
  space.  A return code with nothing following it is required to terminate
  a newline-terminated string.

  Arguments are communicated to the server with ARG commands; these
  optionally take a name for named args.  Args are transmitted one at a
  time until all are sent.  There is no fixed limit on the number of
  arguments.

  This enables names arguments to be sent as easily as passing a hash.
  This means that lots of things can be rewritten in a much simpler manner
  now.  Drat.

  The utility/dispatch difference serves to reinforce the distinction
  between these types of functions; dispatch functions all take the same
  arguments.

- Figure out how to moreclosely link bounce reasons with access control
  actions.  Problem: we can only generate bounce reasons before we call
  access_check.  We can't generate all possible reasons and we might not
  want to generate any.  The owner can't choose which reasons to use, and
  can't add any.

  can add a clear_reasons action, and a reason action to erase the reasons
  list and add additional bounce reasons.  This makes the access_control
  stuff look uglier than it needs to be, although continuation lines can
  help.

- mj_resend should go through the dispatcher and use the iterative
  interface instead of the direct post function.

- bounce handling
    Parse all mail to owner alias, looking for bounces.
    Do periodic single-address-probes.
    When bouncing address detected, put on bounce status.
    Send bounce probe daily(?) with token that changes status back to
     active.
    Remove from list after N days.

    Use sequence numbers in envelopes to determine when to put an address
    on the bounce list: after N consecutive bounced messages (N
    configurable, of course; low-traffic lists will want to remove after
    one bounce?

    Make additional piece of subscriber data indicating that an address
    should be explicitly bounce probed (perhaps if the address was found to
    be bouncing from a bounce parse or if an explicit bounce probe came
    back).  The idea is to make sure that we continue to probe a bouncing
    message until it no longer bounces or until we see enough true bounces
    to remove the address.  We don't want to remove for intermittent
    failures, because the user will complain about having to return himself
    from bounce status often.

    We already have a bounce field in the subscriber database; use it to
    store message numbers that bounce or a generic "found a bounce" tag,
    along with timestamps.  If this field is non-null, always probe the
    address.  The bounce handler can look at this field and determine what
    to do when it gets a bounce based upon the history there.

    Periodic trigger can remove old bounce data after so many days.

- uniquify function names
    Make function names unique to 8 characters, to appease AutoSplit.

- Verify that non-wrapper configuration is correct
      create a dummy script, make it setuid, and run it.  If it errors, we
      know it's bad.

- store some data on each user-request so we can limit abusers.  Basically
  we want to store enough data to see if an address is sending too many
  requests to us.  a circular list of a fixed size would probably be good;
  we save it between sessions and if an address shows up too many times we
  set an access flag before running the access check.
    One big global queue?
    One queue per request?
    One queue per list?
    One queue per list per request?
    Something else?  Some kind of time average per address per request?
  How do we allow things like someone who works offline and dumps a pile of
   email every couple of days?
  How do we back off when a user gets close to the limit?  We don't want to
   just start ignoring requests.  We could sleep, then sleep some more,
   then bounce, then reject, then ignore progressively as the traffic
   increases.
  How to make sure that a slow server that has only a few users doesn't
   fill up a queue with only a few addresses causing them to bounce?  Store
   address and a timestamp and ignore/purge old requests?
  How to store this data?  Probably not in the config file.


Categorized ideas:
-----------------

Config Stuff
- Variables for default_class, default_digest, all of the various digest
  modes, all of the default flag settings.
- passwords <<  asdf : !config
- proper checking of non-optional args in table-parse

Email Interface
- prescan for bad situations: unmatched tokens, too many subscribes in one
  message, etc.
- prescan for access restriction override.
- context-sensitive help: TextOutput routines return list of help topics
  with error; email interface looks up topics and mails back appropriate
  help.
- make sure that no internal routine gets called with an undefined list:
  "subscribe" sent with no deflist set.

Majordomo.pm
- resubscribe (change address)

TextOutput
- rekey ALL or GLOBAL
- info ALL for hyper-long lists output
- auxshow list ALL
- aux lists for GLOBAL?
- alias ALL.

Finish access restriction mechanism 
- need better syntax checking
- mondo documentation

Confirmation/Approval engine
- Ability to append or prepend information to approved messages
- list tokens, expire old tokens.

Resend
- MIME transformations
- Address exclusion on CC or nocopy.

Mj::Log
- Log classes; too much debug info now
- Have aborts and warnings stuffed into some tempfile and process that file
  after the fact.  This allows aborts to propogate even if we've hosed the
  mail delivery system.

Aliasing
- Should aliases be global only?
  To do this, we need a global database of all addresses with aliases
  and all of the lists they belong to.  Maybe we need a global
  database of all addresses on any lists.  This may be a bad thing.
  Perhaps we could get away with complete list membership checking for
  alias ops, but that looks like a bad thing.  Global actions that
  potentially affect all lists are not good; they probably shouldn't
  be triggerable by anyone on the net.

  After more thought, it seems that checking list memberships for every
  alias call isn't that bad an idea; alias calls probably won't be that
  common and we to it anyway for extended lists output.  We have to check
  that the destination is subscribed to at least one list, and that the
  source is not subscribed to any lists.  The unalias call just needs to
  remove the alias if it exists, and shouldn't require any additional
  checking.

Aux address lists
???

Meta
- Add proper $VERSION tags for all modules.
- Figure out the proper names for functions and clean them all up.
- Figure out how do make all messages configurable.
- Make sure that addresses are validated/stripped as little as possible.
  If a routine can return an error string and needs to strip the address,
  it can save upstream functions the trouble.
- Try to avoid aborting when there is another way.  Unfortunately, aborting
  happens at the lowest levels of the code (that would have to be working
  anyway in order to send abort messages).
- Try to decide at just which level should the address be validated.
- Make stub modules that inherit from the real modules so people have a
  place to put their extension/overriding code without copying things
  around.

List
- Make sure that tabs don't leak in from the interfaces.
- Cache is_subscriber data, since some operations may check this more than
  once per run.  (lists=enhanced with some advertise settings, e.g.)
- Cache flag data, since flags can get set in chunks.  Alternately,
  make flag_set take a list of flags.

SimpleDB
- Keep list in sorted order to speed up searches (use seek and binary
  search?) and pull out rows in sorted order (for domain-based grouping in
  the delivery engine).  Or just recode the thing to use BTrees.
- Clean up lookup methods; they're a mess.  Collapse duplicated code.
- Code to sort list given a coderef to a compare function.

GTK client
telnet client
web client - Bill
Finish all commands
Figure out client-server spec.


Uncategorized random thinkos:
----------------------------

retrieve and replace individual subscriber field data, for hard-core admin
 stuff.
Subscription policy patch -> sponsored subscribes.
Waiting period for new subscribers?
Partial digests when converting to single message receipt.
archive search engine?
Integrate Dave's logmail stuff -> stats command.
Support for multipart/alternative when sending welcome messages.
Periodically sort lists for proper batching.
Spellcheck the documentation and messages.
PGP verification for email.  How to trust a client?
Internally equate meta-lists * and ALL (valid_list)
Limit message delivery/email request processing to certain times/load
  averages
Some way to store some data until the next time a user communicates with
  us.  So if, say, they are unsubscribed due to bounces but later try to
  send a message or check their subscription status they will be informed.
  Obviously we can't inform them when remove them, since that message would
  bounce, too.
Make access_check for "access" return some sort of session key, so that it
  can be passed in $auth?
Objectify the parser, then register legal methods with it?
Bounce handling:  hack on BounceFilter and AutoBounce.
Simple patterns: just '*' as "match any"; set "simple_patterns" variable,
  and if set do $var =~ s/\*/\001/g; $var = qm($var); $var =~ s/\001/.*/g;
  on every list config read that doesn't default when type =~ /regexp/.
Novice_level variable that affects getting documentation for config
  variables?  Novice set of config variables?  Novice config documentation?
Extra access variables for post method; any_admin, any_taboo, any_dup, etc.
Header length and body length limits.  (body is easy; compute content-length).
digestvolume command to increment (default) or set the volume number for a
  digest.
Expiration of subscriptions.
Last posting date.
Resend sequence numbers: keep a state file per list with the current
  sequence.  Allow setting of the sequence number.
Have who expand lists subscribed to current list.
Clean up the flag and class setting code.
Access_rules methods for checking against requesting user instead of victim.
Forward to other (or same) server, but change the list name.
-c option to mj_email (or new mj_command script) to always execute a
  command when a mail is received.
Tokens with infinite lifetime bound to addresses; use this for a permanent
  unsubscribe token that works if addresses change or whatever.  Scan
  occasionally for bound tokens and eliminate them if the address is no
  longer subscribed.
Switch $mode and $cmdline in public Majordomo functions.
Have 'help command xxx' look up config comment string for xxx.
Support X-No-Archive.  _post should look for headers and pseudo-headers,
  but not remove pseudos if found.
Createlist should mail information to the list owner.  This should be
  some distilled version of list-owner-info, containing pointers to
  additional documents that can be retrieved with the help command.
  Of course, all of these documents need to be written.
Add Majordomo version info to the X-Mailer header that MIME-Tools adds.
Make a separate repository for the backup default files so that we can
 upload them without worrying about overwriting local modifications.
Handle stupid crap like "subscribe to list" and "subscribe list digest".
Some kind of pseudo-anonymizer so that users' addresses are replaced by
 some anonymous token; when the message hits the archives, the headers are
 replaced by this.  This prevents harvesting of addresses from the
 archives.  Majordomo can handle the mapping between tokens and addresses.
Allow a 'default prefix' command to specify a prefix to strip from all
 lines in the text parser.  This allows replies to be yanked and quoted, as
 long as they aren't line wrapped.
Allow 'approve password' on the line before the command to be approved.
New 'append' mode to configset to append additional data from a variable
 instead of replacing the existing data.
Add additional sender information to things like confirmations so that if
 they bounce, the bounce processor can take care of the generated token and
 not forward the bounce to the owner.
Allow referencing sublists of other lists in access_rules.
Digests with detached bodies; send just a table of contents and let the
 client retrieve the messages they want.
Do RBL lookups on hosts found in received headers.
Somehow attach the parsed defaults to the config file.  Problem: we have to
 pull in mj_cf_defs and eval it to get the defaults if we hit a defaulted
 variable, but in order to parse it we have to suck in mj_cf_data and
 chunks of Config.pm.  This is slow.  We could eval the defaults ones,
 stick them in the config file along with a timestamp, then just do a stat
 on the defaults file to see if we need to update.
Allow access control language to make modifications to outgoing messages,
 perhaps by passing a list of actions back to the access check routine
 before the message is spooled.
Keep a list of banned domains, compare against them in resend and fail all
 commands from them in the email interface (or, perhaps, in the
 dispatcher).
Purge archive files after a certain period of time.
Make archiver add files into filespace with useful descriptions.
Change commands executed/successful to counts of
 total/executed/pending/failed or somesuch.
Allow headers to vary depending on access variables.
Have an action attach text to an outgoing message (warning about quotes,
 deleted parts, etc.)
Always allocating address objects for every core call costs for iterators;
 invent some handle method instead so we can cache state between calls.
If processing a command yields an invalid address error and following line
 does not hold a legal command, join the two lines and try again.
